{
    "docs": [
        {
            "location": "/", 
            "text": "Colyseus is a Authoritative Multiplayer Game Server for Node.js. It allows you to focus on your gameplay instead of bothering about networking.\n\n\nThe mission of this framework is to be the easiest solution for creating your\nown multiplayer games in JavaScript.\n\n\nThis framework is fairly new and is being evolved constantly. You're encouraged to take a look on \nsome games being developed with it\n and make your own!\n\n\nWhat Colyseus provides to you:\n\n\n\n\nWebSocket-based communication\n\n\nSimple API in the server-side and client-side.\n\n\nAutomatic state synchronization between server and client.\n\n\nMatchmaking clients into game sessions\n\n\nScale vertically or horizontally\n\n\n\n\nWhat Colyseus won't provide:\n\n\n\n\nGame Engine: Colyseus is agnostic of the engine you're using. Need Physics? Add your own logic / package.\n\n\nDatabase: It's up to you to configure and select which database you'd like to use.\n\n\n\n\nWhat people are saying about it?\n\n\n\n\n@bmovement\n\n\n\"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\"\n\n\n\n\n\n\n@sagestudios\n\n\nLoved the framework. Exactly what we are looking for in terms of features.\n\n\n\n\nExternal links\n\n\n\n\n\ud83c\udf10 \n Website\n\n\n\ud83d\udcac \n Forum\n\n\n\ud83d\udcb0 \n Support the project", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-colyseus-provides-to-you", 
            "text": "WebSocket-based communication  Simple API in the server-side and client-side.  Automatic state synchronization between server and client.  Matchmaking clients into game sessions  Scale vertically or horizontally", 
            "title": "What Colyseus provides to you:"
        }, 
        {
            "location": "/#what-colyseus-wont-provide", 
            "text": "Game Engine: Colyseus is agnostic of the engine you're using. Need Physics? Add your own logic / package.  Database: It's up to you to configure and select which database you'd like to use.", 
            "title": "What Colyseus won't provide:"
        }, 
        {
            "location": "/#what-people-are-saying-about-it", 
            "text": "@bmovement  \"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\"    @sagestudios  Loved the framework. Exactly what we are looking for in terms of features.", 
            "title": "What people are saying about it?"
        }, 
        {
            "location": "/#external-links", 
            "text": "\ud83c\udf10   Website  \ud83d\udcac   Forum  \ud83d\udcb0   Support the project", 
            "title": "External links"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started\n\n\nEnvironment\n\n\nColyseus requires \nNode.js\n v6.0.0 or higher.\n\n\nSee some examples in action by cloning the \nexamples\n project and running it locally.\n\n\ngit clone https://github.com/gamestdio/colyseus-examples.git\ncd colyseus-examples\nnpm install\n\n\n\n\n\nTo run the http + websocket server, run \nnpm start\n.\n\n\nThe Mindset\n\n\nThe authoritative game server mindset is quite simple. The Server validates the user actions, and clients are dumb visual representations of the current game state.\n\n\nThe server should take care of all data involved in your game, such as positioning, speeds, collisions, etc.\n\n\nMaking multiplayer games is usually tricky because your gameplay must take the multiple delays into account - the other clients sending data to the server, and the server sending data back to all clients. It's the art of faking something that has already happened is actually happening as the current player sees and plays the game.\n\n\nHere's how the \"multiplayer game loop\" looks like on Colyseus:\n\n\n\n\nClient sends a message to the server, requesting to change its state.\n\n\nThe input must be validated by your room handler.\n\n\nThe game state is updated.\n\n\nAll clients receive the latest version of the game state.\n\n\nThe visual representation of the game state is updated.\n\n\n\n\nDiagram\n\n\n              room.send({ action: \nleft\n })\n\n                           |\n      +------------+       |       +-----------------------------------+\n+-----+ Client #1  +-------|       |  Room handler #1                  |\n|     +------------+       |       |                                   |\n|     +------------+       |       |  onMessage (client, data) {       |\n|-----+ Client #2  |       --------+    if (data.action === \nleft\n) {  |\n|     +------------+               |      // update the room state     |\n|     +------------+               |    }                              |\n|-----+ Client #3  |               |  }                                |\n|     +------------+               +-----------------------------------+\n|                                                    |\n|        patch state broadcast (binary diff)         |\n|----------------------------------------------------+\n\n\n\n\n\nRecommended NodeJS packages for games\n\n\nThese modules can be useful while developing games on both NodeJS and the Browser.\n\n\n\n\n@gamestdio/mathf\n - Mathematical functions, borrowed from Unity3D's API\n\n\n@gamestdio/timer\n - Reliable timing events\n\n\n@gamestdio/keycode\n - Constants for keyboard key codes (\nevent.which\n)\n\n\n\n\nThese modules can be used only in the browser:\n\n\n\n\n@gamestdio/pixi-engine", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#environment", 
            "text": "Colyseus requires  Node.js  v6.0.0 or higher.  See some examples in action by cloning the  examples  project and running it locally.  git clone https://github.com/gamestdio/colyseus-examples.git\ncd colyseus-examples\nnpm install  To run the http + websocket server, run  npm start .", 
            "title": "Environment"
        }, 
        {
            "location": "/getting-started/#the-mindset", 
            "text": "The authoritative game server mindset is quite simple. The Server validates the user actions, and clients are dumb visual representations of the current game state.  The server should take care of all data involved in your game, such as positioning, speeds, collisions, etc.  Making multiplayer games is usually tricky because your gameplay must take the multiple delays into account - the other clients sending data to the server, and the server sending data back to all clients. It's the art of faking something that has already happened is actually happening as the current player sees and plays the game.  Here's how the \"multiplayer game loop\" looks like on Colyseus:   Client sends a message to the server, requesting to change its state.  The input must be validated by your room handler.  The game state is updated.  All clients receive the latest version of the game state.  The visual representation of the game state is updated.", 
            "title": "The Mindset"
        }, 
        {
            "location": "/getting-started/#diagram", 
            "text": "room.send({ action:  left  })\n\n                           |\n      +------------+       |       +-----------------------------------+\n+-----+ Client #1  +-------|       |  Room handler #1                  |\n|     +------------+       |       |                                   |\n|     +------------+       |       |  onMessage (client, data) {       |\n|-----+ Client #2  |       --------+    if (data.action ===  left ) {  |\n|     +------------+               |      // update the room state     |\n|     +------------+               |    }                              |\n|-----+ Client #3  |               |  }                                |\n|     +------------+               +-----------------------------------+\n|                                                    |\n|        patch state broadcast (binary diff)         |\n|----------------------------------------------------+", 
            "title": "Diagram"
        }, 
        {
            "location": "/getting-started/#recommended-nodejs-packages-for-games", 
            "text": "These modules can be useful while developing games on both NodeJS and the Browser.   @gamestdio/mathf  - Mathematical functions, borrowed from Unity3D's API  @gamestdio/timer  - Reliable timing events  @gamestdio/keycode  - Constants for keyboard key codes ( event.which )   These modules can be used only in the browser:   @gamestdio/pixi-engine", 
            "title": "Recommended NodeJS packages for games"
        }, 
        {
            "location": "/concept-state-synchronization/", 
            "text": "State synchronization\n\n\n\n\nColyseus uses \nMessagePack\n to encode the room state in a binary format.\n\n\nUpon first connection, the client receives the latest full binary room state.\n\n\nThe binary patch is evaluated through \nFossil's Delta algorithm\n at every \npatch interval\n.\n\n\nThe patched room state is sent to all connected clients.", 
            "title": "State synchronization"
        }, 
        {
            "location": "/concept-state-synchronization/#state-synchronization", 
            "text": "Colyseus uses  MessagePack  to encode the room state in a binary format.  Upon first connection, the client receives the latest full binary room state.  The binary patch is evaluated through  Fossil's Delta algorithm  at every  patch interval .  The patched room state is sent to all connected clients.", 
            "title": "State synchronization"
        }, 
        {
            "location": "/concept-matchmaking/", 
            "text": "To allow matchmaking on your Colyseus server, you'll need to implement a room handler, and register it in your server.\n\n\nSee:\n\n\n\n\nRoom\n\n\nServer#register()\n\n\n\n\nThe matchmaking cycle\n\n\n1.\n Client asks to connect into a specific room:\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \n// client-side\n\n\nlet\n \nroom\n \n=\n \nclient\n.\njoin\n(\nbattle\n);\n\n\n\n\n        \n\n    \n        \n\n            \n// client-side\n\n\nRoom\n \nroom\n \n=\n \nclient\n.\nJoin\n(\nbattle\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n2.\n Server will loop through all spawned room instances named \n\"battle\"\n and call \nrequestJoin\n method against that instance.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nExample 1\n\n        \n\n    \n        \n\n            \nExample 2\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \n// server-side\n\n\nrequestJoin\n \n(\noptions\n: \nany\n)\n \n{\n\n    \n// Prevent the client from joining the same room from another browser tab\n\n    \nreturn\n \nthis\n.\nclients\n.\nfilter\n(\nc\n \n=\n \nc\n.\nid\n \n===\n \noptions\n.\nclientId\n).\nlength\n \n===\n \n0\n;\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \n// server-side\n\n\nonInit\n \n(\noptions\n: \nany\n)\n \n{\n\n    \nthis\n.\npassword\n \n=\n \noptions\n.\npassword\n;\n\n\n}\n\n\n\nrequestJoin\n \n(\noptions\n: \nany\n)\n \n{\n\n    \n// Private room. Only accept connections with the correct password.\n\n    \nreturn\n \nthis\n.\npassword\n \n===\n \noptions\n.\npassword\n;\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n3.\n If \nrequestJoin\n succeeds, \nRoom#onJoin()\n will be called with the \nclient\n reference and \noptions\n given by the client.\n\n\n4.\n If \nrequestJoin\n fails on every available room instance, a new instance will be spawned for that client. In case \nrequestJoin\n fails again, the client will receive an \n\"error\"\n event.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \n// client-side\n\n\nroom\n.\nonError\n.\nadd\n(\nfunction\n(\nerr\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nerror ocurred:\n,\n \nerr\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \n// client-side\n\n\nroom\n.\nOnError\n \n+=\n \n(\nobject\n \nsender\n,\n \nMessageEventArgs\n \ne\n)\n \n=\n \nDebug\n.\nLog\n(\ne\n.\ndata\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nRanked matches\n\n\nAs an alternative to returning \ntrue\n or \nfalse\n on \nrequestJoin\n, you can provide a number between \n0\n and \n1\n to manage priority. The match-making service will select the highest number for the new user to connect.\n\n\nOn this example, we're prioritizing rooms with the fewer number of clients. You can write your own logic to calculate the average skill level of your user, for example.\n\n\nclass\n \nMyRoomHandler\n \nextends\n \nRoom\n \n{\n\n  \n// maximum of 10 clients allowed on this room.\n\n  \nmaxClients\n \n=\n \n10\n;\n\n\n  \nrequestJoin\n \n(\noptions\n: \nany\n)\n \n{\n\n    \nreturn\n \n1\n \n-\n \n(\nthis\n.\nclients\n.\nlength\n \n/\n \n10\n);\n\n  \n}\n\n\n}", 
            "title": "Matchmaking"
        }, 
        {
            "location": "/concept-matchmaking/#the-matchmaking-cycle", 
            "text": "1.  Client asks to connect into a specific room:  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             // client-side  let   room   =   client . join ( battle );  \n\n         \n    \n         \n             // client-side  Room   room   =   client . Join ( battle );  \n\n         \n    \n         \n    \n                 \n                      2.  Server will loop through all spawned room instances named  \"battle\"  and call  requestJoin  method against that instance.  \n                 \n                    \n         \n            \n         \n             Example 1 \n         \n    \n         \n             Example 2 \n         \n    \n         \n    \n         \n            \n         \n             // server-side  requestJoin   ( options :  any )   { \n     // Prevent the client from joining the same room from another browser tab \n     return   this . clients . filter ( c   =   c . id   ===   options . clientId ). length   ===   0 ;  }  \n\n         \n    \n         \n             // server-side  onInit   ( options :  any )   { \n     this . password   =   options . password ;  }  requestJoin   ( options :  any )   { \n     // Private room. Only accept connections with the correct password. \n     return   this . password   ===   options . password ;  }  \n\n         \n    \n         \n    \n                 \n                      3.  If  requestJoin  succeeds,  Room#onJoin()  will be called with the  client  reference and  options  given by the client.  4.  If  requestJoin  fails on every available room instance, a new instance will be spawned for that client. In case  requestJoin  fails again, the client will receive an  \"error\"  event.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             // client-side  room . onError . add ( function ( err )   { \n     console . log ( error ocurred: ,   err );  });  \n\n         \n    \n         \n             // client-side  room . OnError   +=   ( object   sender ,   MessageEventArgs   e )   =   Debug . Log ( e . data );", 
            "title": "The matchmaking cycle"
        }, 
        {
            "location": "/concept-matchmaking/#ranked-matches", 
            "text": "As an alternative to returning  true  or  false  on  requestJoin , you can provide a number between  0  and  1  to manage priority. The match-making service will select the highest number for the new user to connect.  On this example, we're prioritizing rooms with the fewer number of clients. You can write your own logic to calculate the average skill level of your user, for example.  class   MyRoomHandler   extends   Room   { \n   // maximum of 10 clients allowed on this room. \n   maxClients   =   10 ; \n\n   requestJoin   ( options :  any )   { \n     return   1   -   ( this . clients . length   /   10 ); \n   }  }", 
            "title": "Ranked matches"
        }, 
        {
            "location": "/api-server/", 
            "text": "Web-Socket Server\n\n\nServer\n\n\nThe \nServer\n is responsible for providing the WebSocket server to enable communication between server and client.\n\n\nconstructor (options)\n\n\noptions.server\n\n\nThe HTTP server to bind the WebSocket Server into. You may use \nexpress\n for your server too.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n            \nTypeScript (express)\n\n        \n\n    \n        \n\n            \nJavaScript (express)\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \ncreateServer\n \n}\n \nfrom\n \nhttp\n;\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n\n  \nserver\n: \ncreateServer\n()\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncolyseus\n \n=\n \nrequire\n(\ncolyseus\n);\n\n\nconst\n \nhttp\n \n=\n \nrequire\n(\nhttp\n);\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \ncolyseus\n.\nServer\n({\n\n  \nserver\n: \nhttp.createServer\n()\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \ncreateServer\n \n}\n \nfrom\n \nhttp\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n\n  \nserver\n: \ncreateServer\n(\napp\n)\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncolyseus\n \n=\n \nrequire\n(\ncolyseus\n);\n\n\nconst\n \nhttp\n \n=\n \nrequire\n(\nhttp\n);\n\n\nconst\n \nexpress\n \n=\n \nrequire\n(\nexpress\n);\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \ncolyseus\n.\nServer\n({\n\n  \nserver\n: \nhttp.createServer\n(\napp\n)\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\noptions.engine\n\n\nYou may provide a different WebSocket engine. By default, it uses\n\nws\n. You may use\n\nuws\n by passing it as a reference.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \ncreateServer\n \n}\n \nfrom\n \nhttp\n;\n\n\nimport\n \n*\n \nas\n \nWebSocket\n \nfrom\n \nuws\n;\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n\n  \nengine\n: \nWebSocket.Server\n,\n\n  \nserver\n: \ncreateServer\n()\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncolyseus\n \n=\n \nrequire\n(\ncolyseus\n);\n\n\nconst\n \nhttp\n \n=\n \nrequire\n(\nhttp\n);\n\n\nconst\n \nWebSocket\n \n=\n \nrequire\n(\nuws\n)\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \ncolyseus\n.\nServer\n({\n\n  \nengine\n:\n \nWebSocket\n.\nServer\n,\n\n  \nserver\n:\n \nhttp\n.\ncreateServer\n()\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\noptions.verifyClient\n\n\nThis method happens before WebSocket handshake. If \nverifyClient\n is not set\nthen the handshake is automatically accepted.\n\n\n\n\n\n\ninfo\n (Object)\n\n\n\n\norigin\n (String) The value in the Origin header indicated by the client.\n\n\nreq\n (http.IncomingMessage) The client HTTP GET request.\n\n\nsecure\n (Boolean) \ntrue\n if \nreq.connection.authorized\n or \nreq.connection.encrypted\n is set.\n\n\n\n\n\n\n\n\nnext\n (Function) A callback that must be called by the user upon inspection of the \ninfo\n fields. Arguments in this callback are:\n\n\n\n\nresult\n (Boolean) Whether or not to accept the handshake.\n\n\ncode\n (Number) When \nresult\n is \nfalse\n this field determines the HTTP error status code to be sent to the client.\n\n\nname\n (String) When \nresult\n is \nfalse\n this field determines the HTTP reason phrase.\n\n\n\n\n\n\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \ncreateServer\n \n}\n \nfrom\n \nhttp\n;\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n\n  \nserver\n: \ncreateServer\n(),\n\n  \nverifyClient\n: \nfunction\n \n(\ninfo\n,\n \nnext\n)\n \n{\n\n    \n// validate \ninfo\n\n    \n//\n\n    \n// - next(false) will reject the websocket handshake\n\n    \n// - next(true) will accept the websocket handshake\n\n  \n}\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncolyseus\n \n=\n \nrequire\n(\ncolyseus\n);\n\n\nconst\n \nhttp\n \n=\n \nrequire\n(\nhttp\n);\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \ncolyseus\n.\nServer\n({\n\n  \nserver\n: \ncreateServer\n(),\n\n  \nverifyClient\n: \nfunction\n \n(\ninfo\n,\n \nnext\n)\n \n{\n\n    \n// validate \ninfo\n\n    \n//\n\n    \n// - next(false) will reject the websocket handshake\n\n    \n// - next(true) will accept the websocket handshake\n\n  \n}\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\noptions.presence\n\n\nWhen scaling Colyseus through multiple processes / machines, you need to provide a presence server.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nServer\n,\n \nRedisPresence\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \ncreateServer\n \n}\n \nfrom\n \nhttp\n;\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n\n  \nserver\n: \ncreateServer\n(),\n\n  \npresence\n: \nnew\n \nRedisPresence\n()\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncolyseus\n \n=\n \nrequire\n(\ncolyseus\n);\n\n\nconst\n \nhttp\n \n=\n \nrequire\n(\nhttp\n);\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \ncolyseus\n.\nServer\n({\n\n  \nserver\n: \ncreateServer\n(),\n\n  \npresence\n: \nnew\n \ncolyseus\n.\nRedisPresence\n()\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nThe currently avaialble Presence servers are currently:\n\n\n\n\nRedisPresence\n (scales on a single server and multiple servers)\n\n\nMemsharedPresence\n (scales on a single server)\n\n\n\n\nregister (name: string, handler: Room, options?: any)\n\n\nRegister a new session handler.\n\n\nParameters:\n\n\n\n\nname: string\n - The public name of the room. You'll use this name when joining the room from the client-side.\n\n\nhandler: Room\n - Reference to the \nRoom\n handler class.\n\n\noptions?: any\n - Custom options for room initialization.\n\n\n\n\n// Register \nchat\n room\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n);\n\n\n\n// Register \nbattle\n room\n\n\ngameServer\n.\nregister\n(\nbattle\n,\n \nBattleRoom\n);\n\n\n\n// Register \nbattle\n room with custom options\n\n\ngameServer\n.\nregister\n(\nbattle_woods\n,\n \nBattleRoom\n,\n \n{\n \nmap\n:\n \nwoods\n \n});\n\n\n\n\n\n\n\n\nTip\n\n\nYou may register the same room handler multiple times with different \noptions\n. When \nRoom#onInit()\n is called, the \noptions\n will contain the merged values you specified on \nServer#register()\n + the options provided by the first client on \nclient.join()\n\n\n\n\nListening to matchmake events\n\n\nThe \nregister\n method will return the registered handler instance, which you can listen to match-making events from outside the room instance scope. Such as:\n\n\n\n\n\"create\"\n - when a room has been created\n\n\n\"dispose\"\n - when a room has been disposed\n\n\n\"join\"\n - when a client join a room\n\n\n\"leave\"\n - when a client leave a room\n\n\n\"lock\"\n - when a room has been locked\n\n\n\"unlock\"\n - when a room has been unlocked\n\n\n\n\nUsage:\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n).\n\n  \non\n(\ncreate\n,\n \n(\nroom\n)\n \n=\n \nconsole\n.\nlog\n(\nroom created:\n,\n \nroom\n.\nroomId\n)).\n\n  \non\n(\ndispose\n,\n \n(\nroom\n)\n \n=\n \nconsole\n.\nlog\n(\nroom disposed:\n,\n \nroom\n.\nroomId\n)).\n\n  \non\n(\njoin\n,\n \n(\nroom\n,\n \nclient\n)\n \n=\n \nconsole\n.\nlog\n(\nclient\n.\nid\n,\n \njoined\n,\n \nroom\n.\nroomId\n)).\n\n  \non\n(\nleave\n,\n \n(\nroom\n,\n \nclient\n)\n \n=\n \nconsole\n.\nlog\n(\nclient\n.\nid\n,\n \nleft\n,\n \nroom\n.\nroomId\n));\n\n\n\n\n\n\n\n\nWarning\n\n\nIt's completely discouraged to manipulate a room's state through these events. Use the \nabstract methods\n in your room handler instead.\n\n\n\n\nattach (options: any)\n\n\nAttaches or creates the WebSocket server.\n\n\n\n\noptions.server\n: The HTTP server to attach the WebSocket server on.\n\n\noptions.ws\n: An existing WebSocket server to be re-used.\n\n\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nExpress\n\n        \n\n    \n        \n\n            \nhttp.createServer\n\n        \n\n    \n        \n\n            \nWebSocket.Server\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \napp\n \n=\n \nnew\n \nexpress\n();\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n();\n\n\n\ngameServer\n.\nattach\n({\n \nserver\n:\n \napp\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n*\n \nas\n \nhttp\n \nfrom\n \nhttp\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \nhttpServer\n \n=\n \nhttp\n.\ncreateServer\n();\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n();\n\n\n\ngameServer\n.\nattach\n({\n \nserver\n:\n \nhttpServer\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n*\n \nas\n \nhttp\n \nfrom\n \nhttp\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n*\n \nas\n \nws\n \nfrom\n \nws\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\nconst\n \nserver\n \n=\n \nhttp\n.\ncreateServer\n(\napp\n);\n\n\nconst\n \nwss\n \n=\n \nnew\n \nWebSocket\n.\nServer\n({\n\n    \n// your custom WebSocket.Server setup.\n\n\n});\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n();\n\n\ngameServer\n.\nattach\n({\n \nws\n:\n \nwss\n \n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nlisten (port: number)\n\n\nBinds the WebSocket server into the specified port.\n\n\nonShutdown (callback: Function)\n\n\nRegister a callback that should be called before the process shut down. See \ngraceful shutdown\n for more details.", 
            "title": "Server"
        }, 
        {
            "location": "/api-server/#web-socket-server", 
            "text": "", 
            "title": "Web-Socket Server"
        }, 
        {
            "location": "/api-server/#server", 
            "text": "The  Server  is responsible for providing the WebSocket server to enable communication between server and client.", 
            "title": "Server"
        }, 
        {
            "location": "/api-server/#constructor-options", 
            "text": "", 
            "title": "constructor (options)"
        }, 
        {
            "location": "/api-server/#optionsserver", 
            "text": "The HTTP server to bind the WebSocket Server into. You may use  express  for your server too.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n             TypeScript (express) \n         \n    \n         \n             JavaScript (express) \n         \n    \n         \n    \n         \n            \n         \n             import   {   Server   }   from   colyseus ;  import   {   createServer   }   from   http ;  const   gameServer   =   new   Server ({ \n   server :  createServer ()  });  \n\n         \n    \n         \n             const   colyseus   =   require ( colyseus );  const   http   =   require ( http );  const   gameServer   =   new   colyseus . Server ({ \n   server :  http.createServer ()  });  \n\n         \n    \n         \n             import   {   Server   }   from   colyseus ;  import   {   createServer   }   from   http ;  import   *   as   express   from   express ;  const   app   =   express ();  const   gameServer   =   new   Server ({ \n   server :  createServer ( app )  });  \n\n         \n    \n         \n             const   colyseus   =   require ( colyseus );  const   http   =   require ( http );  const   express   =   require ( express );  const   app   =   express ();  const   gameServer   =   new   colyseus . Server ({ \n   server :  http.createServer ( app )  });", 
            "title": "options.server"
        }, 
        {
            "location": "/api-server/#optionsengine", 
            "text": "You may provide a different WebSocket engine. By default, it uses ws . You may use uws  by passing it as a reference.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   {   Server   }   from   colyseus ;  import   {   createServer   }   from   http ;  import   *   as   WebSocket   from   uws ;  const   gameServer   =   new   Server ({ \n   engine :  WebSocket.Server , \n   server :  createServer ()  });  \n\n         \n    \n         \n             const   colyseus   =   require ( colyseus );  const   http   =   require ( http );  const   WebSocket   =   require ( uws )  const   gameServer   =   new   colyseus . Server ({ \n   engine :   WebSocket . Server , \n   server :   http . createServer ()  });", 
            "title": "options.engine"
        }, 
        {
            "location": "/api-server/#optionsverifyclient", 
            "text": "This method happens before WebSocket handshake. If  verifyClient  is not set\nthen the handshake is automatically accepted.    info  (Object)   origin  (String) The value in the Origin header indicated by the client.  req  (http.IncomingMessage) The client HTTP GET request.  secure  (Boolean)  true  if  req.connection.authorized  or  req.connection.encrypted  is set.     next  (Function) A callback that must be called by the user upon inspection of the  info  fields. Arguments in this callback are:   result  (Boolean) Whether or not to accept the handshake.  code  (Number) When  result  is  false  this field determines the HTTP error status code to be sent to the client.  name  (String) When  result  is  false  this field determines the HTTP reason phrase.     \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   {   Server   }   from   colyseus ;  import   {   createServer   }   from   http ;  const   gameServer   =   new   Server ({ \n   server :  createServer (), \n   verifyClient :  function   ( info ,   next )   { \n     // validate  info \n     // \n     // - next(false) will reject the websocket handshake \n     // - next(true) will accept the websocket handshake \n   }  });  \n\n         \n    \n         \n             const   colyseus   =   require ( colyseus );  const   http   =   require ( http );  const   gameServer   =   new   colyseus . Server ({ \n   server :  createServer (), \n   verifyClient :  function   ( info ,   next )   { \n     // validate  info \n     // \n     // - next(false) will reject the websocket handshake \n     // - next(true) will accept the websocket handshake \n   }  });", 
            "title": "options.verifyClient"
        }, 
        {
            "location": "/api-server/#optionspresence", 
            "text": "When scaling Colyseus through multiple processes / machines, you need to provide a presence server.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   {   Server ,   RedisPresence   }   from   colyseus ;  import   {   createServer   }   from   http ;  const   gameServer   =   new   Server ({ \n   server :  createServer (), \n   presence :  new   RedisPresence ()  });  \n\n         \n    \n         \n             const   colyseus   =   require ( colyseus );  const   http   =   require ( http );  const   gameServer   =   new   colyseus . Server ({ \n   server :  createServer (), \n   presence :  new   colyseus . RedisPresence ()  });  \n\n         \n    \n         \n    \n                 \n                      The currently avaialble Presence servers are currently:   RedisPresence  (scales on a single server and multiple servers)  MemsharedPresence  (scales on a single server)", 
            "title": "options.presence"
        }, 
        {
            "location": "/api-server/#register-name-string-handler-room-options-any", 
            "text": "Register a new session handler.  Parameters:   name: string  - The public name of the room. You'll use this name when joining the room from the client-side.  handler: Room  - Reference to the  Room  handler class.  options?: any  - Custom options for room initialization.   // Register  chat  room  gameServer . register ( chat ,   ChatRoom );  // Register  battle  room  gameServer . register ( battle ,   BattleRoom );  // Register  battle  room with custom options  gameServer . register ( battle_woods ,   BattleRoom ,   {   map :   woods   });    Tip  You may register the same room handler multiple times with different  options . When  Room#onInit()  is called, the  options  will contain the merged values you specified on  Server#register()  + the options provided by the first client on  client.join()", 
            "title": "register (name: string, handler: Room, options?: any)"
        }, 
        {
            "location": "/api-server/#listening-to-matchmake-events", 
            "text": "The  register  method will return the registered handler instance, which you can listen to match-making events from outside the room instance scope. Such as:   \"create\"  - when a room has been created  \"dispose\"  - when a room has been disposed  \"join\"  - when a client join a room  \"leave\"  - when a client leave a room  \"lock\"  - when a room has been locked  \"unlock\"  - when a room has been unlocked   Usage:  gameServer . register ( chat ,   ChatRoom ). \n   on ( create ,   ( room )   =   console . log ( room created: ,   room . roomId )). \n   on ( dispose ,   ( room )   =   console . log ( room disposed: ,   room . roomId )). \n   on ( join ,   ( room ,   client )   =   console . log ( client . id ,   joined ,   room . roomId )). \n   on ( leave ,   ( room ,   client )   =   console . log ( client . id ,   left ,   room . roomId ));    Warning  It's completely discouraged to manipulate a room's state through these events. Use the  abstract methods  in your room handler instead.", 
            "title": "Listening to matchmake events"
        }, 
        {
            "location": "/api-server/#attach-options-any", 
            "text": "Attaches or creates the WebSocket server.   options.server : The HTTP server to attach the WebSocket server on.  options.ws : An existing WebSocket server to be re-used.   \n                 \n                    \n         \n            \n         \n             Express \n         \n    \n         \n             http.createServer \n         \n    \n         \n             WebSocket.Server \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   express   from   express ;  import   {   Server   }   from   colyseus ;  const   app   =   new   express ();  const   gameServer   =   new   Server ();  gameServer . attach ({   server :   app   });  \n\n         \n    \n         \n             import   *   as   http   from   http ;  import   {   Server   }   from   colyseus ;  const   httpServer   =   http . createServer ();  const   gameServer   =   new   Server ();  gameServer . attach ({   server :   httpServer   });  \n\n         \n    \n         \n             import   *   as   http   from   http ;  import   *   as   express   from   express ;  import   *   as   ws   from   ws ;  import   {   Server   }   from   colyseus ;  const   app   =   express ();  const   server   =   http . createServer ( app );  const   wss   =   new   WebSocket . Server ({ \n     // your custom WebSocket.Server setup.  });  const   gameServer   =   new   Server ();  gameServer . attach ({   ws :   wss   });", 
            "title": "attach (options: any)"
        }, 
        {
            "location": "/api-server/#listen-port-number", 
            "text": "Binds the WebSocket server into the specified port.", 
            "title": "listen (port: number)"
        }, 
        {
            "location": "/api-server/#onshutdown-callback-function", 
            "text": "Register a callback that should be called before the process shut down. See  graceful shutdown  for more details.", 
            "title": "onShutdown (callback: Function)"
        }, 
        {
            "location": "/api-room/", 
            "text": "Room API (Server-side)\n\n\nConsidering that you already \nset up your server\n, now it's time to register session handlers, and start accepting connections from your users.\n\n\nYou'll define session handlers creating classes that extends from \nRoom\n.\n\n\nimport\n \n{\n \nRoom\n,\n \nClient\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nexport\n \nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \n// Authorize client based on provided options before WebSocket handshake is complete\n\n    \nonAuth\n \n(\noptions\n: \nany\n)\n \n{\n \n}\n\n\n    \n// When room is initialized\n\n    \nonInit\n \n(\noptions\n: \nany\n)\n \n{\n \n}\n\n\n    \n// Checks if a new client is allowed to join. (default: `return true`)\n\n    \nrequestJoin\n \n(\noptions\n: \nany\n,\n \nisNew\n: \nboolean\n)\n \n{\n \n}\n\n\n    \n// When client successfully join the room\n\n    \nonJoin\n \n(\nclient\n: \nClient\n)\n \n{\n \n}\n\n\n    \n// When a client leaves the room\n\n    \nonLeave\n \n(\nclient\n: \nClient\n,\n \nconsented\n: \nboolean\n)\n \n{\n \n}\n\n\n    \n// When a client sends a message\n\n    \nonMessage\n \n(\nclient\n: \nClient\n,\n \nmessage\n: \nany\n)\n \n{\n \n}\n\n\n    \n// Cleanup callback, called after there are no more clients in the room. (see `autoDispose`)\n\n    \nonDispose\n \n()\n \n{\n \n}\n\n\n}\n\n\n\n\n\n\nAbstract methods\n\n\nRoom handlers can implement all these methods.\n\n\nonInit (options)\n\n\nIs called once when room is initialized. You may specify custom initialization options when registering the room handler.\n\n\n\n\nTip\n\n\nThe \noptions\n will contain the merged values you specified on \nServer#register()\n + the options provided by the first client on \nclient.join()\n\n\n\n\nrequestJoin (options, isNew)\n\n\nParameters:\n\n\n\n\noptions\n: The options provided by the client (\nclient.join()\n), merged with options provided by the server (\ngameServer.register()\n).\n\n\nisNew\n: will be \ntrue\n for rooms being created and \nfalse\n for existing ones.\n\n\n\n\nSynchronous function to check if a new client is allowed to join.\n\n\nIf left non-implemented, this method returns \ntrue\n, allowing any client to connect.\n\n\nonAuth (options)\n\n\nCan be used to verify authenticity of the client that's joining the room.\n\n\nIf left non-implemented it returns \ntrue\n, allowing any client to connect.\n\n\nSee \nauthentication\n section.\n\n\nonJoin (client, options, auth?)\n\n\nParameters:\n\n\n\n\nclient\n: The \nclient\n instance.\n\n\noptions\n: merged values specified on \nServer#register()\n with the options provided the client on \nclient.join()\n\n\nauth\n: (optional) auth data returned by \nonAuth\n method.\n\n\n\n\nIs called when client successfully join the room, after \nrequestJoin\n and \nonAuth\n has been succeeded.\n\n\nonMessage (client, data)\n\n\nIs called when a client sends a message to the server. Here's where you'll process client actions to update the room's state.\n\n\nExample:\n\n\nonMessage\n \n(\nclient\n,\n \ndata\n)\n \n{\n\n    \nlet\n \nplayer\n \n=\n \nthis\n.\nplayersByClientId\n.\nget\n(\nclient\n);\n\n\n    \nif\n \n(\ndata\n.\ncommand\n \n===\n \nleft\n)\n \n{\n\n        \nplayer\n.\nx\n \n-=\n \n1\n;\n\n\n    \n}\n \nelse\n \nif\n \n(\ndata\n.\ncommand\n \n===\n \nright\n)\n \n{\n\n        \nplayer\n.\nx\n \n+=\n \n1\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nonLeave (client, consented)\n\n\nIs called when a client leave the room. If the disconnection was \ninitiated by the client\n, the \nconsented\n parameter will be \ntrue\n, otherwise, it will be \nfalse\n.\n\n\nYou can define this function as \nasync\n. See \ngraceful shutdown\n\n\nonDispose ()\n\n\nCleanup callback, called after there are no more clients in the room.\n\n\nYou can define this function as \nasync\n. See \ngraceful shutdown\n\n\nPublic properties\n\n\nclients: WebSocket[]\n\n\nThe array of connected clients. See \nWeb-Socket Client\n.\n\n\nmaxClients: number\n\n\nMaximum number of clients allowed to connect into the room. When room reaches\nthis limit, it is locked automatically. Unless the room was explicitly locked by\nyou via \nlock()\n method, the room will be unlocked as soon as a client\ndisconnects from it.\n\n\npatchRate: number\n\n\nFrequency to send the room state to connected clients (in milliseconds)\n\n\nSee \nstate synchronization\n.\n\n\nautoDispose: boolean\n\n\nAutomatically dispose the room when last client disconnect. (default: \ntrue\n)\n\n\nlocked: boolean\n (read-only)\n\n\nThis property will change on these situations:\n\n\n\n\nThe maximum number of allowed clients has been reached (\nmaxClients\n)\n\n\nYou manually locked, or unlocked the room using \nlock()\n or \nunlock()\n.\n\n\n\n\nclock: ClockTimer\n\n\nA \nClockTimer\n instance, used for\n\ntiming events\n.\n\n\nPublic methods\n\n\nRoom handlers have these methods available.\n\n\nsetState (object)\n\n\nSet the new room state.\n\n\n\n\nWarning\n\n\nDo not call this method for updates in the room state. The binary patch algorithm is re-set every time you call it.\n\n\n\n\n\n\nTip\n\n\nYou'll usually call this method only once (on \nRoom.onInit()\n) in your room handler.\n\n\n\n\nsetSimulationInterval (callback[, milliseconds=16.6])\n\n\n(Optional) Create the simulation interval that will change the state of the game. Default simulation interval: 16.6ms (60fps)\n\n\nsetPatchRate (milliseconds)\n\n\nSet frequency the patched state should be sent to all clients. (default: \n50\n = 20fps)\n\n\nsetMetadata (metadata)\n\n\nSet metadata for the room instance. This metadata is public when requesting the\nroom list through \nclient.getAvailableRooms()\n method.\n\n\nsetSeatReservationTime (seconds)\n\n\n(Default=3) Set the number of seconds a room can wait for a client to effectively join the room. You should consider how long your \nonAuth()\n will have to wait for setting a different seat reservation time. The default value is usually good enough.\n\n\nsend (client, message)\n\n\nSend a message to a particular client.\n\n\nthis\n.\nsend\n(\nclient\n,\n \n{\n \nmessage\n:\n \nHello world!\n \n});\n\n\n\n\n\n\n\n\nTip\n\n\nSee how to handle these messages on client-side.\n\n\n\n\nbroadcast ( message )\n\n\nSend a message to all connected clients.\n\n\n\n\nTip\n\n\nSee how to handle these messages on client-side.\n\n\n\n\nlock ()\n\n\nLocking the room will remove it from the pool of available rooms for new clients to connect to.\n\n\nunlock ()\n\n\nUnlocking the room returns it to the pool of available rooms for new clients to connect to.\n\n\ndisconnect ()\n\n\nDisconnect all clients, then dispose.\n\n\nallowReconnection (client, seconds)\n\n\nAllow the specified client to \nrejoin\n into the room. Must be unsed inside \nonLeave()\n method.\n\n\nasync\n \nonLeave\n \n(\nclient\n)\n \n{\n\n  \n// flag client as inactive for other users\n\n  \nthis\n.\nstate\n.\ninactivateClient\n(\nclient\n);\n\n\n  \ntry\n \n{\n\n    \n// allow disconnected client to rejoin into this room until 20 seconds\n\n    \nawait\n \nthis\n.\nallowReconnection\n(\nclient\n,\n \n20\n);\n\n\n    \n// client returned! let\ns re-activate it.\n\n    \nthis\n.\nstate\n.\nactivateClient\n(\nclient\n);\n\n\n  \n}\n \ncatch\n \n(\ne\n)\n \n{\n\n\n    \n// 20 seconds expired. let\ns remove the client.\n\n    \nthis\n.\nstate\n.\nremoveClient\n(\nclient\n);\n\n  \n}\n\n\n}", 
            "title": "Room"
        }, 
        {
            "location": "/api-room/#room-api-server-side", 
            "text": "Considering that you already  set up your server , now it's time to register session handlers, and start accepting connections from your users.  You'll define session handlers creating classes that extends from  Room .  import   {   Room ,   Client   }   from   colyseus ;  export   class   MyRoom   extends   Room   { \n     // Authorize client based on provided options before WebSocket handshake is complete \n     onAuth   ( options :  any )   {   } \n\n     // When room is initialized \n     onInit   ( options :  any )   {   } \n\n     // Checks if a new client is allowed to join. (default: `return true`) \n     requestJoin   ( options :  any ,   isNew :  boolean )   {   } \n\n     // When client successfully join the room \n     onJoin   ( client :  Client )   {   } \n\n     // When a client leaves the room \n     onLeave   ( client :  Client ,   consented :  boolean )   {   } \n\n     // When a client sends a message \n     onMessage   ( client :  Client ,   message :  any )   {   } \n\n     // Cleanup callback, called after there are no more clients in the room. (see `autoDispose`) \n     onDispose   ()   {   }  }", 
            "title": "Room API (Server-side)"
        }, 
        {
            "location": "/api-room/#abstract-methods", 
            "text": "Room handlers can implement all these methods.", 
            "title": "Abstract methods"
        }, 
        {
            "location": "/api-room/#oninit-options", 
            "text": "Is called once when room is initialized. You may specify custom initialization options when registering the room handler.   Tip  The  options  will contain the merged values you specified on  Server#register()  + the options provided by the first client on  client.join()", 
            "title": "onInit (options)"
        }, 
        {
            "location": "/api-room/#requestjoin-options-isnew", 
            "text": "Parameters:   options : The options provided by the client ( client.join() ), merged with options provided by the server ( gameServer.register() ).  isNew : will be  true  for rooms being created and  false  for existing ones.   Synchronous function to check if a new client is allowed to join.  If left non-implemented, this method returns  true , allowing any client to connect.", 
            "title": "requestJoin (options, isNew)"
        }, 
        {
            "location": "/api-room/#onauth-options", 
            "text": "Can be used to verify authenticity of the client that's joining the room.  If left non-implemented it returns  true , allowing any client to connect.  See  authentication  section.", 
            "title": "onAuth (options)"
        }, 
        {
            "location": "/api-room/#onjoin-client-options-auth", 
            "text": "Parameters:   client : The  client  instance.  options : merged values specified on  Server#register()  with the options provided the client on  client.join()  auth : (optional) auth data returned by  onAuth  method.   Is called when client successfully join the room, after  requestJoin  and  onAuth  has been succeeded.", 
            "title": "onJoin (client, options, auth?)"
        }, 
        {
            "location": "/api-room/#onmessage-client-data", 
            "text": "Is called when a client sends a message to the server. Here's where you'll process client actions to update the room's state.  Example:  onMessage   ( client ,   data )   { \n     let   player   =   this . playersByClientId . get ( client ); \n\n     if   ( data . command   ===   left )   { \n         player . x   -=   1 ; \n\n     }   else   if   ( data . command   ===   right )   { \n         player . x   +=   1 ; \n     }  }", 
            "title": "onMessage (client, data)"
        }, 
        {
            "location": "/api-room/#onleave-client-consented", 
            "text": "Is called when a client leave the room. If the disconnection was  initiated by the client , the  consented  parameter will be  true , otherwise, it will be  false .  You can define this function as  async . See  graceful shutdown", 
            "title": "onLeave (client, consented)"
        }, 
        {
            "location": "/api-room/#ondispose", 
            "text": "Cleanup callback, called after there are no more clients in the room.  You can define this function as  async . See  graceful shutdown", 
            "title": "onDispose ()"
        }, 
        {
            "location": "/api-room/#public-properties", 
            "text": "", 
            "title": "Public properties"
        }, 
        {
            "location": "/api-room/#clients-websocket", 
            "text": "The array of connected clients. See  Web-Socket Client .", 
            "title": "clients: WebSocket[]"
        }, 
        {
            "location": "/api-room/#maxclients-number", 
            "text": "Maximum number of clients allowed to connect into the room. When room reaches\nthis limit, it is locked automatically. Unless the room was explicitly locked by\nyou via  lock()  method, the room will be unlocked as soon as a client\ndisconnects from it.", 
            "title": "maxClients: number"
        }, 
        {
            "location": "/api-room/#patchrate-number", 
            "text": "Frequency to send the room state to connected clients (in milliseconds)  See  state synchronization .", 
            "title": "patchRate: number"
        }, 
        {
            "location": "/api-room/#autodispose-boolean", 
            "text": "Automatically dispose the room when last client disconnect. (default:  true )", 
            "title": "autoDispose: boolean"
        }, 
        {
            "location": "/api-room/#locked-boolean-read-only", 
            "text": "This property will change on these situations:   The maximum number of allowed clients has been reached ( maxClients )  You manually locked, or unlocked the room using  lock()  or  unlock() .", 
            "title": "locked: boolean (read-only)"
        }, 
        {
            "location": "/api-room/#clock-clocktimer", 
            "text": "A  ClockTimer  instance, used for timing events .", 
            "title": "clock: ClockTimer"
        }, 
        {
            "location": "/api-room/#public-methods", 
            "text": "Room handlers have these methods available.", 
            "title": "Public methods"
        }, 
        {
            "location": "/api-room/#setstate-object", 
            "text": "Set the new room state.   Warning  Do not call this method for updates in the room state. The binary patch algorithm is re-set every time you call it.    Tip  You'll usually call this method only once (on  Room.onInit() ) in your room handler.", 
            "title": "setState (object)"
        }, 
        {
            "location": "/api-room/#setsimulationinterval-callback-milliseconds166", 
            "text": "(Optional) Create the simulation interval that will change the state of the game. Default simulation interval: 16.6ms (60fps)", 
            "title": "setSimulationInterval (callback[, milliseconds=16.6])"
        }, 
        {
            "location": "/api-room/#setpatchrate-milliseconds", 
            "text": "Set frequency the patched state should be sent to all clients. (default:  50  = 20fps)", 
            "title": "setPatchRate (milliseconds)"
        }, 
        {
            "location": "/api-room/#setmetadata-metadata", 
            "text": "Set metadata for the room instance. This metadata is public when requesting the\nroom list through  client.getAvailableRooms()  method.", 
            "title": "setMetadata (metadata)"
        }, 
        {
            "location": "/api-room/#setseatreservationtime-seconds", 
            "text": "(Default=3) Set the number of seconds a room can wait for a client to effectively join the room. You should consider how long your  onAuth()  will have to wait for setting a different seat reservation time. The default value is usually good enough.", 
            "title": "setSeatReservationTime (seconds)"
        }, 
        {
            "location": "/api-room/#send-client-message", 
            "text": "Send a message to a particular client.  this . send ( client ,   {   message :   Hello world!   });    Tip  See how to handle these messages on client-side.", 
            "title": "send (client, message)"
        }, 
        {
            "location": "/api-room/#broadcast-message", 
            "text": "Send a message to all connected clients.   Tip  See how to handle these messages on client-side.", 
            "title": "broadcast ( message )"
        }, 
        {
            "location": "/api-room/#lock", 
            "text": "Locking the room will remove it from the pool of available rooms for new clients to connect to.", 
            "title": "lock ()"
        }, 
        {
            "location": "/api-room/#unlock", 
            "text": "Unlocking the room returns it to the pool of available rooms for new clients to connect to.", 
            "title": "unlock ()"
        }, 
        {
            "location": "/api-room/#disconnect", 
            "text": "Disconnect all clients, then dispose.", 
            "title": "disconnect ()"
        }, 
        {
            "location": "/api-room/#allowreconnection-client-seconds", 
            "text": "Allow the specified client to  rejoin  into the room. Must be unsed inside  onLeave()  method.  async   onLeave   ( client )   { \n   // flag client as inactive for other users \n   this . state . inactivateClient ( client ); \n\n   try   { \n     // allow disconnected client to rejoin into this room until 20 seconds \n     await   this . allowReconnection ( client ,   20 ); \n\n     // client returned! let s re-activate it. \n     this . state . activateClient ( client ); \n\n   }   catch   ( e )   { \n\n     // 20 seconds expired. let s remove the client. \n     this . state . removeClient ( client ); \n   }  }", 
            "title": "allowReconnection (client, seconds)"
        }, 
        {
            "location": "/api-client/", 
            "text": "Web-Socket Client\n\n\nThe \nclient\n instance present on:\n\n\n\n\nRoom#clients\n\n\nRoom#onJoin()\n\n\nRoom#onMessage()\n\n\nRoom#onLeave()\n\n\n\n\n\n\nNote\n\n\nThis is the raw WebSocket connection coming from the \nws\n package. There are more methods available which aren't encouraged to use along with Colyseus.\n\n\n\n\nProperties\n\n\nid: string\n\n\nUnique id per client. When the same client connects with multiple browser tabs, the \nid\n will be the same for every connection.\n\n\nsessionId: string\n\n\nUnique id per session. Whilst you may have the same \nid\n for multiple sessions from the same client, the \nsessionId\n is always unique.\n\n\nMethods\n\n\nclose(code?: number)\n\n\nForce disconnection of the \nclient\n with the server.\n\n\n\n\nTip\n\n\nThis will trigger \nroom.onLeave\n event on the client-side.", 
            "title": "Client"
        }, 
        {
            "location": "/api-client/#web-socket-client", 
            "text": "The  client  instance present on:   Room#clients  Room#onJoin()  Room#onMessage()  Room#onLeave()    Note  This is the raw WebSocket connection coming from the  ws  package. There are more methods available which aren't encouraged to use along with Colyseus.", 
            "title": "Web-Socket Client"
        }, 
        {
            "location": "/api-client/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/api-client/#id-string", 
            "text": "Unique id per client. When the same client connects with multiple browser tabs, the  id  will be the same for every connection.", 
            "title": "id: string"
        }, 
        {
            "location": "/api-client/#sessionid-string", 
            "text": "Unique id per session. Whilst you may have the same  id  for multiple sessions from the same client, the  sessionId  is always unique.", 
            "title": "sessionId: string"
        }, 
        {
            "location": "/api-client/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/api-client/#closecode-number", 
            "text": "Force disconnection of the  client  with the server.   Tip  This will trigger  room.onLeave  event on the client-side.", 
            "title": "close(code?: number)"
        }, 
        {
            "location": "/api-timing-events/", 
            "text": "For \ntiming events\n,\nit's recommended to use the \nthis.clock\n methods,\nfrom your \nRoom\n instance.\n\n\n\n\nTip\n\n\nAll intervals and timeouts registered on\n\nthis.clock\n are cleared automatically when\nthe \nRoom\n is disposed.\n\n\n\n\n\n\nImportant\n\n\nThe built-in\n\nsetTimeout\n\nand\n\nsetInterval\n\nmethods rely on CPU load, which may delay an unexpected amount of time to execute.\n\n\n\n\nClock\n\n\nPublic methods\n\n\nclock.setInterval(callback, time, ...args): Delayed\n\n\nThe \nsetInterval()\n method repeatedly calls a function or executes a code\nsnippet, with a fixed time delay between each call. It returns\n\nDelayed\n instance which identifies the interval, so you can\nmanipulate it later.\n\n\nclock.setTimeout(callback, time, ...args): Delayed\n\n\nThe \nsetTimeout()\n method sets a timer which executes a function or specified\npiece of code once after the timer expires. It returns \nDelayed\n\ninstance which identifies the interval, so you can manipulate it later.\n\n\nclock.clear()\n\n\nClear all intervals and timeouts registered with \nclock.setInterval()\n and \nclock.setTimeout()\n.\n\n\nclock.start()\n\n\nStart counting time.\n\n\nclock.stop()\n\n\nStop counting time.\n\n\nclock.tick()\n\n\nThis method is called automatically at every simulation interval step. All\n\nDelayed\n instances are checked during \ntick\n.\n\n\n\n\nTip\n\n\nSee \nRoom#setSimiulationInterval()\n for more details.\n\n\n\n\nPublic properties\n\n\nclock.elapsedTime\n\n\nElased time in milliseconds since \nclock.start()\n method was called. Read only.\n\n\nclock.currentTime\n\n\nCurrent time in milliseconds. Read only.\n\n\nclock.deltaTime\n\n\nThe difference in milliseconds between the last and current \nclock.tick()\n call. Read only.\n\n\nDelayed\n\n\nDelayed instances are created from\n\nclock.setInterval()\n or\n\nclock.setTimeout()\n methods.\n\n\nPublic methods\n\n\ndelayed.clear()\n\n\nClears the timeout or interval.\n\n\ndelayed.reset()\n\n\nReset the elapsed time.\n\n\nPublic properties\n\n\ndelayed.active: boolean\n\n\nReturns \ntrue\n if timer is still running.", 
            "title": "Timing events"
        }, 
        {
            "location": "/api-timing-events/#clock", 
            "text": "", 
            "title": "Clock"
        }, 
        {
            "location": "/api-timing-events/#public-methods", 
            "text": "", 
            "title": "Public methods"
        }, 
        {
            "location": "/api-timing-events/#clocksetintervalcallback-time-args-delayed", 
            "text": "The  setInterval()  method repeatedly calls a function or executes a code\nsnippet, with a fixed time delay between each call. It returns Delayed  instance which identifies the interval, so you can\nmanipulate it later.", 
            "title": "clock.setInterval(callback, time, ...args): Delayed"
        }, 
        {
            "location": "/api-timing-events/#clocksettimeoutcallback-time-args-delayed", 
            "text": "The  setTimeout()  method sets a timer which executes a function or specified\npiece of code once after the timer expires. It returns  Delayed \ninstance which identifies the interval, so you can manipulate it later.", 
            "title": "clock.setTimeout(callback, time, ...args): Delayed"
        }, 
        {
            "location": "/api-timing-events/#clockclear", 
            "text": "Clear all intervals and timeouts registered with  clock.setInterval()  and  clock.setTimeout() .", 
            "title": "clock.clear()"
        }, 
        {
            "location": "/api-timing-events/#clockstart", 
            "text": "Start counting time.", 
            "title": "clock.start()"
        }, 
        {
            "location": "/api-timing-events/#clockstop", 
            "text": "Stop counting time.", 
            "title": "clock.stop()"
        }, 
        {
            "location": "/api-timing-events/#clocktick", 
            "text": "This method is called automatically at every simulation interval step. All Delayed  instances are checked during  tick .   Tip  See  Room#setSimiulationInterval()  for more details.", 
            "title": "clock.tick()"
        }, 
        {
            "location": "/api-timing-events/#public-properties", 
            "text": "", 
            "title": "Public properties"
        }, 
        {
            "location": "/api-timing-events/#clockelapsedtime", 
            "text": "Elased time in milliseconds since  clock.start()  method was called. Read only.", 
            "title": "clock.elapsedTime"
        }, 
        {
            "location": "/api-timing-events/#clockcurrenttime", 
            "text": "Current time in milliseconds. Read only.", 
            "title": "clock.currentTime"
        }, 
        {
            "location": "/api-timing-events/#clockdeltatime", 
            "text": "The difference in milliseconds between the last and current  clock.tick()  call. Read only.", 
            "title": "clock.deltaTime"
        }, 
        {
            "location": "/api-timing-events/#delayed", 
            "text": "Delayed instances are created from clock.setInterval()  or clock.setTimeout()  methods.", 
            "title": "Delayed"
        }, 
        {
            "location": "/api-timing-events/#public-methods_1", 
            "text": "", 
            "title": "Public methods"
        }, 
        {
            "location": "/api-timing-events/#delayedclear", 
            "text": "Clears the timeout or interval.", 
            "title": "delayed.clear()"
        }, 
        {
            "location": "/api-timing-events/#delayedreset", 
            "text": "Reset the elapsed time.", 
            "title": "delayed.reset()"
        }, 
        {
            "location": "/api-timing-events/#public-properties_1", 
            "text": "", 
            "title": "Public properties"
        }, 
        {
            "location": "/api-timing-events/#delayedactive-boolean", 
            "text": "Returns  true  if timer is still running.", 
            "title": "delayed.active: boolean"
        }, 
        {
            "location": "/api-room-state/", 
            "text": "The room handlers are \nstateful\n in Colyseus. Each room holds its own state. To allow \nsynchronization\n, you \nmust\n mutate the room's state. The server automatically broadcasts the changes to all connected clients at each patch interval.\n\n\n\n\nTip\n\n\n\n\nFor synchronization with the client-side, see \nclient-side state synchronization\n.\n\n\nSee Colyseus' technical approach on \nstate synchronization\n.\n\n\n\n\n\n\nRaw Object State\n\n\nThe simplest way to deal with the room state is using a raw JavaScript objects directly in the \nRoom\n handler.\n\n\nOn the following example, you'll see:\n\n\n\n\nCreating player upon client connection.\n\n\nHandling client-side actions and updating the state to move \nx\n position.\n\n\nRemoving player upon client disconnection.\n\n\n\n\nimport\n \n{\n \nRoom\n,\n \nClient\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nexport\n \nclass\n \nBattleRoom\n \nextends\n \nRoom\n \n{\n\n\n  \nonInit\n \n(\noptions\n: \nany\n)\n \n{\n\n    \nthis\n.\nsetState\n({\n\n      \nplayers\n:\n \n{}\n\n    \n});\n\n  \n}\n\n\n  \nonJoin\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nstate\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n]\n \n=\n \n{\n\n      \nx\n: \n0\n,\n\n      \ny\n: \n0\n\n    \n};\n\n  \n}\n\n\n  \nonLeave\n \n(\nclient\n)\n \n{\n\n    \ndelete\n \nthis\n.\nstate\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n];\n\n  \n}\n\n\n  \nonMessage\n \n(\nclient\n,\n \ndata\n)\n \n{\n\n    \nif\n \n(\ndata\n.\naction\n \n===\n \nleft\n)\n \n{\n\n      \nthis\n.\nstate\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n].\nx\n \n-=\n \n1\n;\n\n\n    \n}\n \nelse\n \nif\n \n(\ndata\n.\naction\n \n===\n \nright\n)\n \n{\n\n      \nthis\n.\nstate\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n].\nx\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nYour Own Data Structures\n\n\nWhilst it's possible to use raw data directly on \nthis.state\n. The recommended way to handle your state is through your own data structures. By creating your own structures, you can have a more decoupled structure to represent your state.\n\n\nOn the following (rewritten) example, you'll see:\n\n\n\n\nA clean \nBattleRoom\n implementation, directly coupled to the state structure.\n\n\nA large data structure holding the entire room state (\nBattleState\n)\n\n\nUsage of built-in \nEntityMap\n type.\n\n\nMethods manipulating smaller data structures\n\n\n\n\n\n\nA small decoupled data structure representing a single entity (\nPlayer\n)\n\n\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nBattleRoom.ts\n\n        \n\n    \n        \n\n            \nBattleState.ts\n\n        \n\n    \n        \n\n            \nPlayer.ts\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \n// BattleRoom.ts\n\n\nimport\n \n{\n \nRoom\n,\n \nClient\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \nBattleState\n \n}\n \nfrom\n \n./BattleState\n;\n\n\n\nexport\n \nclass\n \nBattleRoom\n \nextends\n \nRoom\nBattleState\n \n{\n\n\n  \nonInit\n \n(\noptions\n: \nany\n)\n \n{\n\n    \nthis\n.\nsetState\n(\nnew\n \nBattleState\n());\n\n  \n}\n\n\n  \nonJoin\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nstate\n.\naddPlayer\n(\nclient\n);\n\n  \n}\n\n\n  \nonLeave\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nstate\n.\nremovePlayer\n(\nclient\n);\n\n  \n}\n\n\n  \nonMessage\n \n(\nclient\n,\n \ndata\n)\n \n{\n\n    \nif\n \n(\ndata\n.\naction\n)\n \n{\n\n      \nthis\n.\nstate\n.\nmovePlayer\n(\nclient\n,\n \ndata\n.\naction\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \n// BattleState.ts\n\n\nimport\n \n{\n \nEntityMap\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \nPlayer\n \n}\n \nfrom\n \n./Player\n;\n\n\n\nexport\n \nclass\n \nBattleState\n \n{\n\n  \nplayers\n: \nEntityMap\nPlayer\n \n=\n \n{};\n\n\n  \naddPlayer\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nplayers\n[\n \nclient\n.\nsesssionId\n \n]\n \n=\n \nnew\n \nPlayer\n(\n0\n,\n \n0\n);\n\n  \n}\n\n\n  \nremovePlayer\n \n(\nclient\n)\n \n{\n\n    \ndelete\n \nthis\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n];\n\n  \n}\n\n\n  \nmovePlayer\n \n(\nclient\n,\n \naction\n)\n \n{\n\n    \nif\n \n(\naction\n \n===\n \nleft\n)\n \n{\n\n      \nthis\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n].\nx\n \n-=\n \n1\n;\n\n\n    \n}\n \nelse\n \nif\n \n(\naction\n \n===\n \nright\n)\n \n{\n\n      \nthis\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n].\nx\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \n// Player.ts\n\n\nexport\n \nclass\n \nPlayer\n \n{\n\n  \nconstructor\n \n(\n\n    \npublic\n \nx\n: \nnumber\n,\n\n    \npublic\n \ny\n: \nnumber\n\n  \n)\n \n{\n\n    \nthis\n.\nx\n \n=\n \nx\n;\n\n    \nthis\n.\ny\n \n=\n \ny\n;\n\n  \n}\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nMap of entities (\nEntityMap\n)\n\n\nThe \nEntityMap\n is useful to have strong data typing during development. Since you cannot use \nMap\n to describe public synchronizeable properties (see \navoid using \nMap\n and \nSet\n), the \nEntityMap\n is used to describe a simple map of keys (\nstring\n) to a custom type (\nT\n).\n\n\ntype\n \nEntityMap\nT\n \n=\n \n{[\n \nentityId\n:\nstring\n \n]\n:\n \nT\n};\n\n\n\n\n\n\nYour state will usualy have at least one usage of \nEntityMap\n for the map of connected clients. As described on \nprevious example\n.\n\n\nPrivate variables (\n@nosync\n)\n\n\nTo prevent private properties from leaking into your clients' state, you need to set those properties as \nnon-enumerable\n. The decorator \n@nosync\n is a syntax sugar for this purpose.\n\n\nexport\n \nclass\n \nPlayer\n \n{\n\n  \nx\n: \nnumber\n;\n\n  \ny\n: \nnumber\n;\n\n\n  \n@nosync\n\n  \nwontBeSynched\n: \nstring\n \n=\n \nThis property won\nt be synched with clients\n;\n\n\n}\n\n\n\n\n\n\nAvoid using \nMap\n, \nSet\n\n\nAvoid using \nMap\n and \nSet\n for public, synchronizeable, properties.\n\n\nUnfortunately, the JavaScript built-in types \nMap\n and \nSet\n aren't serializeable by default. This means MessagePack cannot encode them properly.\n\n\nSee why:\n\n\nvar\n \nmyMap\n \n=\n \nnew\n \nMap\n([[\nk1\n,\n \nv1\n],\n \n[\nk2\n,\n \nv2\n]]);\n\n\n// =\n Map(2) {\nkey\n =\n \nvalue\n, \nkey2\n =\n \nvalue2\n}\n\n\nJSON\n.\nstringify\n(\nmyMap\n);\n\n\n// =\n \n{}\n\n\n\n\n\n\nYou're encouraged to use them for private variables, though. See \n@nosync\n for not synchronizeable properties.\n\n\nAvoid mutating arrays\n\n\n\n\npush\ning new entries is OK - the clients will receive a single \n\"add\"\n operation.\n\n\npop\ning the last entry is OK - the clients will receive a single \n\"remove\"\n operation.\n\n\n\n\nRemoving or inserting entries in-between will generate one \n\"replace\"\n operation for each entry that had the index changed. Be careful to handle these changes in the client-side properly.", 
            "title": "State management"
        }, 
        {
            "location": "/api-room-state/#raw-object-state", 
            "text": "The simplest way to deal with the room state is using a raw JavaScript objects directly in the  Room  handler.  On the following example, you'll see:   Creating player upon client connection.  Handling client-side actions and updating the state to move  x  position.  Removing player upon client disconnection.   import   {   Room ,   Client   }   from   colyseus ;  export   class   BattleRoom   extends   Room   { \n\n   onInit   ( options :  any )   { \n     this . setState ({ \n       players :   {} \n     }); \n   } \n\n   onJoin   ( client )   { \n     this . state . players [   client . sessionId   ]   =   { \n       x :  0 , \n       y :  0 \n     }; \n   } \n\n   onLeave   ( client )   { \n     delete   this . state . players [   client . sessionId   ]; \n   } \n\n   onMessage   ( client ,   data )   { \n     if   ( data . action   ===   left )   { \n       this . state . players [   client . sessionId   ]. x   -=   1 ; \n\n     }   else   if   ( data . action   ===   right )   { \n       this . state . players [   client . sessionId   ]. x   +=   1 ; \n     } \n   }  }", 
            "title": "Raw Object State"
        }, 
        {
            "location": "/api-room-state/#your-own-data-structures", 
            "text": "Whilst it's possible to use raw data directly on  this.state . The recommended way to handle your state is through your own data structures. By creating your own structures, you can have a more decoupled structure to represent your state.  On the following (rewritten) example, you'll see:   A clean  BattleRoom  implementation, directly coupled to the state structure.  A large data structure holding the entire room state ( BattleState )  Usage of built-in  EntityMap  type.  Methods manipulating smaller data structures    A small decoupled data structure representing a single entity ( Player )   \n                 \n                    \n         \n            \n         \n             BattleRoom.ts \n         \n    \n         \n             BattleState.ts \n         \n    \n         \n             Player.ts \n         \n    \n         \n    \n         \n            \n         \n             // BattleRoom.ts  import   {   Room ,   Client   }   from   colyseus ;  import   {   BattleState   }   from   ./BattleState ;  export   class   BattleRoom   extends   Room BattleState   { \n\n   onInit   ( options :  any )   { \n     this . setState ( new   BattleState ()); \n   } \n\n   onJoin   ( client )   { \n     this . state . addPlayer ( client ); \n   } \n\n   onLeave   ( client )   { \n     this . state . removePlayer ( client ); \n   } \n\n   onMessage   ( client ,   data )   { \n     if   ( data . action )   { \n       this . state . movePlayer ( client ,   data . action ); \n     } \n   }  }  \n\n         \n    \n         \n             // BattleState.ts  import   {   EntityMap   }   from   colyseus ;  import   {   Player   }   from   ./Player ;  export   class   BattleState   { \n   players :  EntityMap Player   =   {}; \n\n   addPlayer   ( client )   { \n     this . players [   client . sesssionId   ]   =   new   Player ( 0 ,   0 ); \n   } \n\n   removePlayer   ( client )   { \n     delete   this . players [   client . sessionId   ]; \n   } \n\n   movePlayer   ( client ,   action )   { \n     if   ( action   ===   left )   { \n       this . players [   client . sessionId   ]. x   -=   1 ; \n\n     }   else   if   ( action   ===   right )   { \n       this . players [   client . sessionId   ]. x   +=   1 ; \n     } \n   }  }  \n\n         \n    \n         \n             // Player.ts  export   class   Player   { \n   constructor   ( \n     public   x :  number , \n     public   y :  number \n   )   { \n     this . x   =   x ; \n     this . y   =   y ; \n   }  }", 
            "title": "Your Own Data Structures"
        }, 
        {
            "location": "/api-room-state/#map-of-entities-entitymap", 
            "text": "The  EntityMap  is useful to have strong data typing during development. Since you cannot use  Map  to describe public synchronizeable properties (see  avoid using  Map  and  Set ), the  EntityMap  is used to describe a simple map of keys ( string ) to a custom type ( T ).  type   EntityMap T   =   {[   entityId : string   ] :   T };   Your state will usualy have at least one usage of  EntityMap  for the map of connected clients. As described on  previous example .", 
            "title": "Map of entities (EntityMap)"
        }, 
        {
            "location": "/api-room-state/#private-variables-nosync", 
            "text": "To prevent private properties from leaking into your clients' state, you need to set those properties as  non-enumerable . The decorator  @nosync  is a syntax sugar for this purpose.  export   class   Player   { \n   x :  number ; \n   y :  number ; \n\n   @nosync \n   wontBeSynched :  string   =   This property won t be synched with clients ;  }", 
            "title": "Private variables (@nosync)"
        }, 
        {
            "location": "/api-room-state/#avoid-using-map-set", 
            "text": "Avoid using  Map  and  Set  for public, synchronizeable, properties.  Unfortunately, the JavaScript built-in types  Map  and  Set  aren't serializeable by default. This means MessagePack cannot encode them properly.  See why:  var   myMap   =   new   Map ([[ k1 ,   v1 ],   [ k2 ,   v2 ]]);  // =  Map(2) { key  =   value ,  key2  =   value2 }  JSON . stringify ( myMap );  // =   {}   You're encouraged to use them for private variables, though. See  @nosync  for not synchronizeable properties.", 
            "title": "Avoid using Map, Set"
        }, 
        {
            "location": "/api-room-state/#avoid-mutating-arrays", 
            "text": "push ing new entries is OK - the clients will receive a single  \"add\"  operation.  pop ing the last entry is OK - the clients will receive a single  \"remove\"  operation.   Removing or inserting entries in-between will generate one  \"replace\"  operation for each entry that had the index changed. Be careful to handle these changes in the client-side properly.", 
            "title": "Avoid mutating arrays"
        }, 
        {
            "location": "/api-authentication/", 
            "text": "You may implement the \nonAuth(options)\n method validate the authenticity of your clients.\n\n\nWhen requesting to join a room, that's the order of methods which will be called in your room handler:\n\n\n\n\nrequestJoin\n - should check if a room is available for new clients\n\n\nonAuth (options)\n - should validate the client based on the options provided (i.e. auth token)\n\n\nonJoin (client, options, auth)\n - should initialize the new client into your room's state.\n\n\n\n\nFrom the client-side, you'd call the \njoin\n method with a token from some authentication service (i. e. Facebook):\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nLua\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\njoin\n(\nworld\n,\n \n{\n\n  \naccessToken\n:\n \nyourFacebookAccessToken\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nJoin\n(\nworld\n,\n \nnew\n \n{\n\n  \naccessToken\n \n=\n \nyourFacebookAccessToken\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n:\njoin\n(\nworld\n,\n \n{\n\n  \naccessToken\n \n=\n \nyourFacebookAccessToken\n\n\n})\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nThe \nonAuth\n method in your room handler should return a truthy value if the\naccess token is valid.\n\n\nYou may return custom user-related data, which will be passed on the third\nparameter of \nonJoin\n.\n\n\nSynchronous usage\n\n\nYou can immediatelly return a \nboolean\n value.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nonAuth\n \n(\noptions\n)\n:\n \nboolean\n \n{\n\n    \nreturn\n \n(\noptions\n.\npassword\n \n===\n \nsecret\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAsynchronous usage\n\n\nYou can return a \nPromise\n, and perform some asynchronous task to validate the client.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nonAuth\n \n(\noptions\n)\n:\n \nPromise\nany\n \n{\n\n    \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n      \nvalidateToken\n(\noptions\n.\naccessToken\n,\n \n(\nerr\n,\n \nuserData\n)\n \n=\n \n{\n\n        \nif\n \n(\n!\nerr\n)\n \n{\n\n          \nresolve\n(\nuserData\n);\n\n        \n}\n \nelse\n \n{\n\n          \nreject\n(\nerr\n);\n\n        \n}\n\n      \n});\n\n    \n});\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAlternatively, you can use \nasync\n / \nawait\n, which will return a \nPromise\n under the hood.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nasync\n \nonAuth\n \n(\noptions\n)\n \n{\n\n    \nconst\n \nuserData\n \n=\n \nawait\n \nvalidateToken\n(\noptions\n.\naccessToken\n);\n\n    \nreturn\n \n(\nuserData\n)\n \n?\n \nuserData\n : \nfalse\n;\n\n  \n}\n\n\n}", 
            "title": "Authentication"
        }, 
        {
            "location": "/api-authentication/#synchronous-usage", 
            "text": "You can immediatelly return a  boolean  value.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   onAuth   ( options ) :   boolean   { \n     return   ( options . password   ===   secret ); \n   }  }", 
            "title": "Synchronous usage"
        }, 
        {
            "location": "/api-authentication/#asynchronous-usage", 
            "text": "You can return a  Promise , and perform some asynchronous task to validate the client.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   onAuth   ( options ) :   Promise any   { \n     return   new   Promise (( resolve ,   reject )   =   { \n       validateToken ( options . accessToken ,   ( err ,   userData )   =   { \n         if   ( ! err )   { \n           resolve ( userData ); \n         }   else   { \n           reject ( err ); \n         } \n       }); \n     }); \n   }  }   Alternatively, you can use  async  /  await , which will return a  Promise  under the hood.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   async   onAuth   ( options )   { \n     const   userData   =   await   validateToken ( options . accessToken ); \n     return   ( userData )   ?   userData  :  false ; \n   }  }", 
            "title": "Asynchronous usage"
        }, 
        {
            "location": "/api-graceful-shutdown/", 
            "text": "Graceful Shutdown\n\n\nColyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself:\n\n\n\n\nDisconnect all connected clients asynchronously (\nRoom#onLeave\n)\n\n\nDispose all spawned rooms asynchronously (\nRoom#onDispose\n)\n\n\nPerform optional asynchronous callback before shutting down the process \nServer#onShutdown\n\n\n\n\nIf you're performing async tasks on \nonLeave\n / \nonDispose\n, you should return a \nPromise\n, and resolve it when the task is ready. The same applies to \nonShutdown(callback)\n.\n\n\nReturning a \nPromise\n\n\nBy returning a \nPromise\n, the server will wait for them to be completed before killing the worker process.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonLeave\n \n(\nclient\n)\n \n{\n\n        \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n            \ndoDatabaseOperation\n((\nerr\n,\n \ndata\n)\n \n=\n \n{\n\n                \nif\n \n(\nerr\n)\n \n{\n\n                    \nreject\n(\nerr\n);\n\n                \n}\n \nelse\n \n{\n\n                    \nresolve\n(\ndata\n);\n\n                \n}\n\n            \n});\n\n        \n});\n\n    \n}\n\n\n    \nonDispose\n \n()\n \n{\n\n        \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n            \ndoDatabaseOperation\n((\nerr\n,\n \ndata\n)\n \n=\n \n{\n\n                \nif\n \n(\nerr\n)\n \n{\n\n                    \nreject\n(\nerr\n);\n\n                \n}\n \nelse\n \n{\n\n                    \nresolve\n(\ndata\n);\n\n                \n}\n\n            \n});\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nUsing \nasync\n\n\nThe \nasync\n keyword will makes your function return a \nPromise\n under the hood. \nRead more about Async / Await\n.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nasync\n \nonLeave\n \n(\nclient\n)\n \n{\n\n        \nawait\n \ndoDatabaseOperation\n(\nclient\n);\n\n    \n}\n\n\n    \nasync\n \nonDispose\n \n()\n \n{\n\n        \nawait\n \nremoveRoomFromDatabase\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nProcess shutdown callback\n\n\nYou can also listen for process shutdown by setting a \nonShutdown\n callback.\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nlet\n \nserver\n \n=\n \nnew\n \nServer\n();\n\n\n\nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\nmaster process is being shut down!\n);\n\n\n});", 
            "title": "Graceful shutdown"
        }, 
        {
            "location": "/api-graceful-shutdown/#graceful-shutdown", 
            "text": "Colyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself:   Disconnect all connected clients asynchronously ( Room#onLeave )  Dispose all spawned rooms asynchronously ( Room#onDispose )  Perform optional asynchronous callback before shutting down the process  Server#onShutdown   If you're performing async tasks on  onLeave  /  onDispose , you should return a  Promise , and resolve it when the task is ready. The same applies to  onShutdown(callback) .", 
            "title": "Graceful Shutdown"
        }, 
        {
            "location": "/api-graceful-shutdown/#returning-a-promise", 
            "text": "By returning a  Promise , the server will wait for them to be completed before killing the worker process.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n     onLeave   ( client )   { \n         return   new   Promise (( resolve ,   reject )   =   { \n             doDatabaseOperation (( err ,   data )   =   { \n                 if   ( err )   { \n                     reject ( err ); \n                 }   else   { \n                     resolve ( data ); \n                 } \n             }); \n         }); \n     } \n\n     onDispose   ()   { \n         return   new   Promise (( resolve ,   reject )   =   { \n             doDatabaseOperation (( err ,   data )   =   { \n                 if   ( err )   { \n                     reject ( err ); \n                 }   else   { \n                     resolve ( data ); \n                 } \n             }); \n         }); \n     }  }", 
            "title": "Returning a Promise"
        }, 
        {
            "location": "/api-graceful-shutdown/#using-async", 
            "text": "The  async  keyword will makes your function return a  Promise  under the hood.  Read more about Async / Await .  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n     async   onLeave   ( client )   { \n         await   doDatabaseOperation ( client ); \n     } \n\n     async   onDispose   ()   { \n         await   removeRoomFromDatabase (); \n     }  }", 
            "title": "Using async"
        }, 
        {
            "location": "/api-graceful-shutdown/#process-shutdown-callback", 
            "text": "You can also listen for process shutdown by setting a  onShutdown  callback.  import   {   Server   }   from   colyseus ;  let   server   =   new   Server ();  server . onShutdown ( function   ()   { \n     console . log ( master process is being shut down! );  });", 
            "title": "Process shutdown callback"
        }, 
        {
            "location": "/api-debugging/", 
            "text": "Inspector (\n--inspect\n flag)\n\n\nDebug messages\n\n\n\n\nInspector\n\n\nYou can use the the built-in inspector from Node.js to debug your application.\n\n\n\n\nTip\n\n\nRead more about \nDebugging Node.js Applications\n.\n\n\n\n\nDebug messages\n\n\nThe server provides some debug messages that you can enable individually per category, by setting the \nDEBUG\n environment variable.\n\n\nTo enable all logs, you can run your server using:\n\n\nDEBUG=colyseus:* node server.js\n\n\n\n\n\nSee below all available debug categories with sample outputs.\n\n\ncolyseus:patch\n\n\nLogs the number of bytes and interval between patches broadcasted to all clients.\n\n\ncolyseus:patch \nchat\n (roomId: \nryWiL5rLTZ\n) is sending 28 bytes: +57ms\n\n\n\n\n\ncolyseus:patch:data\n\n\nDisplays a human-readable version of the data broadcasted to all clients.\n\n\ncolyseus:patch:data [ { op: \nreplace\n, path: \n/players/BygiLqrLpZ/x\n, value: 5 } ] +56ms\n\n\n\n\n\ncolyseus:errors\n\n\nLogs whenever unexpected (or expected, internally) errors happens on the server-side.\n\n\ncolyseus:matchmaking\n\n\nLogs whenever a room is spanwed or disposed.\n\n\ncolyseus:matchmaking spawning \nchat\n on worker 77218 +52s\ncolyseus:matchmaking disposing \nchat\n on worker 77218 +2s", 
            "title": "Debugging"
        }, 
        {
            "location": "/api-debugging/#inspector", 
            "text": "You can use the the built-in inspector from Node.js to debug your application.   Tip  Read more about  Debugging Node.js Applications .", 
            "title": "Inspector"
        }, 
        {
            "location": "/api-debugging/#debug-messages", 
            "text": "The server provides some debug messages that you can enable individually per category, by setting the  DEBUG  environment variable.  To enable all logs, you can run your server using:  DEBUG=colyseus:* node server.js  See below all available debug categories with sample outputs.", 
            "title": "Debug messages"
        }, 
        {
            "location": "/api-debugging/#colyseuspatch", 
            "text": "Logs the number of bytes and interval between patches broadcasted to all clients.  colyseus:patch  chat  (roomId:  ryWiL5rLTZ ) is sending 28 bytes: +57ms", 
            "title": "colyseus:patch"
        }, 
        {
            "location": "/api-debugging/#colyseuspatchdata", 
            "text": "Displays a human-readable version of the data broadcasted to all clients.  colyseus:patch:data [ { op:  replace , path:  /players/BygiLqrLpZ/x , value: 5 } ] +56ms", 
            "title": "colyseus:patch:data"
        }, 
        {
            "location": "/api-debugging/#colyseuserrors", 
            "text": "Logs whenever unexpected (or expected, internally) errors happens on the server-side.", 
            "title": "colyseus:errors"
        }, 
        {
            "location": "/api-debugging/#colyseusmatchmaking", 
            "text": "Logs whenever a room is spanwed or disposed.  colyseus:matchmaking spawning  chat  on worker 77218 +52s\ncolyseus:matchmaking disposing  chat  on worker 77218 +2s", 
            "title": "colyseus:matchmaking"
        }, 
        {
            "location": "/client-overview/", 
            "text": "Overview\n\n\nColyseus currently have clients for the platforms:\n\n\n\n\nHTML5\n\n\nUnity3D\n\n\nDefold\n\n\n\n\nNeed a client for another platform? Share your interest on the \ndiscussion board\n!\n\n\nConnecting to the Server\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \nColyseus\n \nfrom\n \ncolyseus.js\n;\n\n\n// ...\n\n\n\nlet\n \nclient\n \n=\n \nnew\n \nColyseus\n.\nClient\n(\nws://localhost:2657\n);\n\n\n\n\n        \n\n    \n        \n\n            \nusing\n \nColyseus\n;\n\n\n// ...\n\n\n\nClient\n \nclient\n \n=\n \nnew\n \nClient\n(\nws://localhost:2657\n);\n\n\n\n\n        \n\n    \n        \n\n            \nlocal\n \nColyseusClient\n \n=\n \nrequire\n(\ncolyseus.client\n)\n\n\n//\n \n...\n\n\n\nlocal\n \nclient\n \n=\n \nColyseusClient\n.\nnew\n(\nws://localhost:2657\n);\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \nio\n.\ncolyseus\n.\nClient\n;\n\n\n// ...\n\n\n\nvar\n client \n=\n \nnew\n \nClient\n(\nws://localhost:2657\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nMethods\n\n\njoin (roomName: string, options: any)\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nlet\n \nroom\n \n=\n \nclient\n.\njoin\n(\nbattle\n);\n\n\n\n\n        \n\n    \n        \n\n            \nRoom\n \nroom\n \n=\n \nclient\n.\nJoin\n(\nbattle\n);\n\n\n\n\n        \n\n    \n        \n\n            \nlocal\n \nroom\n \n=\n \nclient\n:\njoin\n(\nbattle\n)\n\n\n\n\n        \n\n    \n        \n\n            \nvar\n room \n=\n \nclient\n.\njoin\n(\nbattle\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nrejoin (roomName: string, sessionId: string)\n\n\nReconnects the client into a room he was previously connected with.\n\n\nMust be used along with \nallowReconnection()\n in the server-side.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nlet\n \nroom\n \n=\n \nclient\n.\nrejoin\n(\nbattle\n,\n \nSkNaHTazQ\n);\n\n\n\n\n        \n\n    \n        \n\n            \nRoom\n \nroom\n \n=\n \nclient\n.\nReJoin\n(\nbattle\n,\n \nSkNaHTazQ\n);\n\n\n\n\n        \n\n    \n        \n\n            \nlocal\n \nroom\n \n=\n \nclient\n:\nrejoin\n(\nbattle\n,\n \nSkNaHTazQ\n)\n\n\n\n\n        \n\n    \n        \n\n            \nvar\n room \n=\n \nclient\n.\nrejoin\n(\nbattle\n,\n \nSkNaHTazQ\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\ngetAvailableRooms (roomName: string)\n\n\nList all available rooms to connect with the provided \nroomName\n. Locked rooms\nwon't be listed.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\ngetAvailableRooms\n(\nbattle\n,\n \nfunction\n(\nrooms\n,\n \nerr\n)\n \n{\n\n  \nif\n \n(\nerr\n)\n \nconsole\n.\nerror\n(\nerr\n);\n\n  \nrooms\n.\nforEach\n(\nfunction\n(\nroom\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nroom\n.\nroomId\n);\n\n    \nconsole\n.\nlog\n(\nroom\n.\nclients\n);\n\n    \nconsole\n.\nlog\n(\nroom\n.\nmaxClients\n);\n\n    \nconsole\n.\nlog\n(\nroom\n.\nmetadata\n);\n\n  \n});\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nGetAvailableRooms\n(\nbattle\n,\n \n(\nrooms\n:\n \nRoomsAvailable\n,\n \nerr\n:\n \nErrorEventArgs\n)\n \n=\n \n{\n\n  \nrooms\n.\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n:\ngetAvailableRooms\n(\nbattle\n,\n \nfunction\n(\nrooms\n,\n \nerr\n)\n\n  \nif\n \n(\nerr\n)\n \nconsole\n.\nerror\n(\nerr\n);\n\n  \nfor\n \ni\n,\n \nrooms\n \nin\n \npairs\n(\nrooms\n)\n \ndo\n\n    \nprint\n(\nrooms\n[\ni\n].\nroomId\n)\n\n    \nprint\n(\nrooms\n[\ni\n].\nclients\n)\n\n    \nprint\n(\nrooms\n[\ni\n].\nmaxClients\n)\n\n    \nprint\n(\nrooms\n[\ni\n].\nmetadata\n)\n\n  \nend\n\n\nend\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nclose ()\n\n\nClose connection with the server.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\nclose\n();\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nClose\n();\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n:\nclose\n()\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nclose\n();\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nEvents\n\n\nonOpen\n\n\nThis event is triggered when the connection is accepted by the server.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\nonOpen\n.\nadd\n(\nfunction\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nconnection is now open\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nOnOpen\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nconnection is now open\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n:\non\n(\nopen\n,\n \nfunction\n()\n\n  \nprint\n(\nconnection is now open\n)\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nonOpen\n \n=\n \nfunction\n()\n \n{\n\n  \ntrace\n(\nconnection is now open\n);\n\n\n};\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonClose\n\n\nThis event is triggered when the connection is closed.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\nonClose\n.\nadd\n(\nfunction\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nconnection has been closed\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nOnClose\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nconnection has been closed\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n:\non\n(\nclose\n,\n \nfunction\n()\n\n  \nprint\n(\nconnection has been closed\n)\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nonClose\n \n=\n \nfunction\n()\n \n{\n\n  \ntrace\n(\nconnection has been closed\n);\n\n\n};\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonError\n\n\nThis event is triggered when some error occurs in the server.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\nonError\n.\nadd\n(\nfunction\n(\nerr\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nsomething wrong happened\n,\n \nerr\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nOnError\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nsomething wrong happened\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n:\non\n(\nerror\n,\n \nfunction\n()\n\n  \nprint\n(\nsomething wrong happened\n)\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nonError\n \n=\n \nfunction\n()\n \n{\n\n  \ntrace\n(\nsomething wrong happened\n);\n\n\n};\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n\n\n\n\n\n\nProperties\n\n\nid: string\n\n\nUnique identifier for the client.\n\n\n\n\nNote\n\n\nThe same client id can connect into the same room handler when joining from multiple browser tabs.", 
            "title": "Overview"
        }, 
        {
            "location": "/client-overview/#overview", 
            "text": "Colyseus currently have clients for the platforms:   HTML5  Unity3D  Defold   Need a client for another platform? Share your interest on the  discussion board !", 
            "title": "Overview"
        }, 
        {
            "location": "/client-overview/#connecting-to-the-server", 
            "text": "TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   Colyseus   from   colyseus.js ;  // ...  let   client   =   new   Colyseus . Client ( ws://localhost:2657 );  \n\n         \n    \n         \n             using   Colyseus ;  // ...  Client   client   =   new   Client ( ws://localhost:2657 );  \n\n         \n    \n         \n             local   ColyseusClient   =   require ( colyseus.client )  //   ...  local   client   =   ColyseusClient . new ( ws://localhost:2657 );  \n\n         \n    \n         \n             import   io . colyseus . Client ;  // ...  var  client  =   new   Client ( ws://localhost:2657 );", 
            "title": "Connecting to the Server"
        }, 
        {
            "location": "/client-overview/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/client-overview/#join-roomname-string-options-any", 
            "text": "TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             let   room   =   client . join ( battle );  \n\n         \n    \n         \n             Room   room   =   client . Join ( battle );  \n\n         \n    \n         \n             local   room   =   client : join ( battle )  \n\n         \n    \n         \n             var  room  =   client . join ( battle );", 
            "title": "join (roomName: string, options: any)"
        }, 
        {
            "location": "/client-overview/#rejoin-roomname-string-sessionid-string", 
            "text": "Reconnects the client into a room he was previously connected with.  Must be used along with  allowReconnection()  in the server-side.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             let   room   =   client . rejoin ( battle ,   SkNaHTazQ );  \n\n         \n    \n         \n             Room   room   =   client . ReJoin ( battle ,   SkNaHTazQ );  \n\n         \n    \n         \n             local   room   =   client : rejoin ( battle ,   SkNaHTazQ )  \n\n         \n    \n         \n             var  room  =   client . rejoin ( battle ,   SkNaHTazQ );", 
            "title": "rejoin (roomName: string, sessionId: string)"
        }, 
        {
            "location": "/client-overview/#getavailablerooms-roomname-string", 
            "text": "List all available rooms to connect with the provided  roomName . Locked rooms\nwon't be listed.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n    \n         \n            \n         \n             client . getAvailableRooms ( battle ,   function ( rooms ,   err )   { \n   if   ( err )   console . error ( err ); \n   rooms . forEach ( function ( room )   { \n     console . log ( room . roomId ); \n     console . log ( room . clients ); \n     console . log ( room . maxClients ); \n     console . log ( room . metadata ); \n   });  });  \n\n         \n    \n         \n             client . GetAvailableRooms ( battle ,   ( rooms :   RoomsAvailable ,   err :   ErrorEventArgs )   =   { \n   rooms .  });  \n\n         \n    \n         \n             client : getAvailableRooms ( battle ,   function ( rooms ,   err ) \n   if   ( err )   console . error ( err ); \n   for   i ,   rooms   in   pairs ( rooms )   do \n     print ( rooms [ i ]. roomId ) \n     print ( rooms [ i ]. clients ) \n     print ( rooms [ i ]. maxClients ) \n     print ( rooms [ i ]. metadata ) \n   end  end );", 
            "title": "getAvailableRooms (roomName: string)"
        }, 
        {
            "location": "/client-overview/#close", 
            "text": "Close connection with the server.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             client . close ();  \n\n         \n    \n         \n             client . Close ();  \n\n         \n    \n         \n             client : close ()  \n\n         \n    \n         \n             client . close ();", 
            "title": "close ()"
        }, 
        {
            "location": "/client-overview/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/client-overview/#onopen", 
            "text": "This event is triggered when the connection is accepted by the server.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             client . onOpen . add ( function ()   { \n   console . log ( connection is now open );  });  \n\n         \n    \n         \n             client . OnOpen   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( connection is now open );  }  \n\n         \n    \n         \n             client : on ( open ,   function () \n   print ( connection is now open )  end )  \n\n         \n    \n         \n             client . onOpen   =   function ()   { \n   trace ( connection is now open );  };", 
            "title": "onOpen"
        }, 
        {
            "location": "/client-overview/#onclose", 
            "text": "This event is triggered when the connection is closed.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             client . onClose . add ( function ()   { \n   console . log ( connection has been closed );  });  \n\n         \n    \n         \n             client . OnClose   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( connection has been closed );  }  \n\n         \n    \n         \n             client : on ( close ,   function () \n   print ( connection has been closed )  end )  \n\n         \n    \n         \n             client . onClose   =   function ()   { \n   trace ( connection has been closed );  };", 
            "title": "onClose"
        }, 
        {
            "location": "/client-overview/#onerror", 
            "text": "This event is triggered when some error occurs in the server.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             client . onError . add ( function ( err )   { \n   console . log ( something wrong happened ,   err );  });  \n\n         \n    \n         \n             client . OnError   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( something wrong happened );  }  \n\n         \n    \n         \n             client : on ( error ,   function () \n   print ( something wrong happened )  end )  \n\n         \n    \n         \n             client . onError   =   function ()   { \n   trace ( something wrong happened );  };", 
            "title": "onError"
        }, 
        {
            "location": "/client-overview/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/client-overview/#id-string", 
            "text": "Unique identifier for the client.   Note  The same client id can connect into the same room handler when joining from multiple browser tabs.", 
            "title": "id: string"
        }, 
        {
            "location": "/client-room/", 
            "text": "Room API (Client-side)\n\n\nMethods\n\n\nlisten (path: string, callback: Function)\n\n\nListen to room state changes from the room handler.\n\n\nUse this method to synchronize the room state from the server with the clients.\n\n\nExamples\n\n\nListening to map data structures\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nDataChange\n \n}\n \nfrom\n \ncolyseus.js\n;\n\n\n// ...\n\n\n\nroom\n.\nlisten\n(\nplayers/:id\n,\n \n(\nchange\n: \nDataChange\n)\n \n=\n \n{\n\n  \nif\n \n(\nchange\n.\noperation\n \n===\n \nadd\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nnew player added to the state\n);\n\n    \nconsole\n.\nlog\n(\nplayer id:\n,\n \nchange\n.\npath\n.\nid\n);\n\n    \nconsole\n.\nlog\n(\nplayer data:\n,\n \nchange\n.\nvalue\n);\n\n\n  \n}\n \nelse\n \nif\n \n(\nchange\n.\noperation\n \n===\n \nremove\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nplayer has been removed from the state\n);\n\n    \nconsole\n.\nlog\n(\nplayer id:\n,\n \nchange\n.\npath\n.\nid\n);\n\n  \n}\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nusing\n \nColyseus\n;\n\n\n// ...\n\n\n\nroom\n.\nListen\n(\nplayers/:id\n,\n \nOnPlayerChange\n);\n\n\n\nvoid\n \nOnPlayerChange\n \n(\nDataChange\n \nchange\n)\n\n\n{\n\n  \nif\n \n(\nchange\n.\noperation\n \n==\n \nadd\n)\n \n{\n\n    \nDebug\n.\nLog\n \n(\nnew player added to the state\n);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\nvalue\n);\n\n\n  \n}\n \nelse\n \nif\n \n(\nchange\n.\noperation\n \n==\n \nremove\n)\n \n{\n\n    \nDebug\n.\nLog\n \n(\nplayer has been removed from the state\n);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n\n  \n}\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n:\nlisten\n(\nplayers/:id\n,\n \nfunction\n(\nchange\n)\n\n  \nif\n \n(\nchange\n.\noperation\n \n==\n \nadd\n)\n \nthen\n\n    \nprint\n(\nnew player added to the state\n)\n\n    \nprint\n(\nchange\n.\npath\n[\nid\n])\n\n    \nprint\n(\nchange\n.\nvalue\n)\n\n\n  \nelseif\n \n(\nchange\n.\noperation\n \n==\n \nremove\n)\n \nthen\n\n    \nprint\n(\nplayer has been removed from the state\n)\n\n    \nprint\n(\nchange\n.\npath\n[\nid\n])\n\n  \nend\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nlisten\n(\nplayers/:id\n,\n \nfunction\n \n(\nchange\n)\n \n{\n\n  \nif\n \n(\nchange\n.\noperation\n \n==\n=\n \nadd\n)\n \n{\n\n    \ntrace\n(\nnew player added to the state\n);\n\n    \ntrace\n(\nplayer id:\n \n+\n \nchange\n.\npath\n.\nid\n);\n\n    \ntrace\n(\nplayer data:\n \n+\n \nStd\n.\nstring\n(\nchange\n.\nvalue\n));\n\n\n  \n}\n \nelse\n \nif\n \n(\nchange\n.\noperation\n \n==\n=\n \nremove\n)\n \n{\n\n    \ntrace\n(\nplayer has been removed from the state\n);\n\n    \ntrace\n(\nplayer id:\n \n+\n \nchange\n.\npath\n.\nid\n);\n\n  \n}\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nListening to attribute changes of deep data structures\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nDataChange\n \n}\n \nfrom\n \ncolyseus.js\n;\n\n\n// ...\n\n\n\nroom\n.\nlisten\n(\nplayers/:id/:attribute\n,\n \n(\nchange\n: \nDataChange\n)\n \n=\n \n{\n\n  \nconsole\n.\nlog\n(\nchange\n.\noperation\n);\n \n// =\n \nadd\n | \nremove\n | \nreplace\n\n  \nconsole\n.\nlog\n(\nchange\n.\npath\n.\nattribute\n,\n \nhas been changed\n);\n\n  \nconsole\n.\nlog\n(\nchange\n.\npath\n.\nid\n);\n\n  \nconsole\n.\nlog\n(\nchange\n.\nvalue\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nusing\n \nColyseus\n;\n\n\n// ...\n\n\n\nroom\n.\nListen\n(\nplayers/:id/:attribute\n,\n \nOnPlayerAttributeChange\n);\n\n\n\nvoid\n \nOnPlayerAttributeChange\n \n(\nDataChange\n \nchange\n)\n\n\n{\n\n  \nDebug\n.\nLog\n \n(\nchange\n.\noperation\n);\n \n// =\n \nadd\n | \nremove\n | \nreplace\n\n  \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nattribute\n]\n \n+\n \nhas been changed\n);\n\n  \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n\n  \nDebug\n.\nLog\n \n(\nchange\n.\nvalue\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n:\nlisten\n(\nplayers/:id/:attribute\n,\n \nfunction\n()\n\n  \nprint\n(\nchange\n.\noperation\n)\n \n//\n \n=\n \nadd\n \n|\n \nremove\n \n|\n \nreplace\n\n  \nprint\n(\nchange\n.\npath\n[\nattribute\n]\n \n+\n \nhas been changed\n)\n\n  \nprint\n(\nchange\n.\npath\n[\nid\n])\n\n  \nprint\n(\nchange\n.\nvalue\n)\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nlisten\n(\nplayers/:id/:attribute\n,\n \nfunction\n(\nchange\n)\n \n{\n\n  \ntrace\n(\nchange\n.\noperation\n);\n \n// =\n \nadd\n | \nremove\n | \nreplace\n\n  \ntrace\n(\nchange\n.\npath\n.\nattribute\n \n+\n \n has been changed\n);\n\n  \ntrace\n(\nchange\n.\npath\n.\nid\n);\n\n  \ntrace\n(\nStd\n.\nstring\n(\nchange\n.\nvalue\n));\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n\n\nTip\n\n\nSee \nState synchronization\n for more examples on how to use the \nlisten\n method.\n\n\n\n\nsend (data)\n\n\nSend message to the room handler.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nsend\n({\n \nmove\n:\n \nleft\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nSend\n(\nnew\n \n{\n \nmove\n \n=\n \nleft\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n:\nsend\n({\n \nmove\n \n=\n \nleft\n \n})\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nsend\n({\n \nmove\n:\n \nleft\n \n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nUse \nRoom#onMessage()\n from the server-side to read the message.\n\n\nleave ()\n\n\nDisconnect from the room.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nleave\n();\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nLeave\n();\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n:\nleave\n()\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nleave\n();\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n\n\nTip\n\n\nUse \nRoom#onLeave()\n to handle the disconnection from the server-side.\n\n\n\n\nremoveAllListeners()\n\n\nRemove all event and data listeners.\n\n\nProperties\n\n\nid: string\n\n\nThe unique idenfitier of the room. You can share this id with other clients in\norder to allow them to connect directly to this room.\n\n\n// get `roomId` from the query string\n\n\nlet\n \nroomId\n \n=\n \nlocation\n.\nhref\n.\nmatch\n(\n/roomId=([a-zA-Z0-9\\-_]+)/\n)[\n1\n];\n\n\n\n// connect the client directly into a specific room id\n\n\nlet\n \nroom\n \n=\n \nclient\n.\njoin\n(\nroomId\n);\n\n\n\n\n\n\n\n\nWarning\n\n\nIf you're looking for the unique identifier of the client, use \nclient.id\n instead.\n\n\n\n\nsessionId: string\n\n\nUnique session identifier.\n\n\nThis property matches the \nclient.sessionId\n from the server-side.\n\n\nname: string\n\n\nName of the room handler. Ex: \n\"battle\"\n.\n\n\nstate: any\n\n\nThe current room's state. This variable is always synched with the latest\n\nstate\n from the server-side. To listen for updates on the whole state, see\n\nonStateChange\n event.\n\n\nEvents\n\n\nonStateChange\n\n\nThis event is triggered when the server updates its state.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonStateChange\n.\naddOnce\n(\nfunction\n(\nstate\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nthis is the first room state!\n,\n \nstate\n);\n\n\n});\n\n\n\nroom\n.\nonStateChange\n.\nadd\n(\nfunction\n(\nstate\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nthe room state has been updated:\n,\n \nstate\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnStateChange\n \n+=\n \n(\nobject\n \nsender\n,\n \nRoomUpdateEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nif\n \n(\ne\n.\nisFirstState\n)\n \n{\n\n    \nDebug\n.\nLog\n \n(\nthis is the first room state!\n);\n\n  \n}\n\n\n  \nDebug\n.\nLog\n \n(\nthe room state has been updated\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n:\non\n(\nstatechange\n,\n \nfunction\n(\nstate\n)\n\n  \nprint\n(\nnew state:\n,\n \nstate\n)\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nonStateChange\n \n=\n \nfunction\n(\nstate\n)\n \n{\n\n  \ntrace\n(\nnew state:\n \n+\n \nStd\n.\nstring\n(\nstate\n));\n\n\n};\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonMessage\n\n\nThis event is triggered when the server sends a message directly to the client.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonMessage\n.\nadd\n(\nfunction\n(\nmessage\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nserver just sent this message:\n);\n\n  \nconsole\n.\nlog\n(\nmessage\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnMessage\n \n+=\n \n(\nobject\n \nsender\n,\n \nMessageEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nserver just sent this message:\n);\n\n  \nDebug\n.\nLog\n(\ne\n.\nmessage\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n:\non\n(\nmessage\n,\n \nfunction\n(\nmessage\n)\n\n  \nprint\n(\nserver just sent this message:\n)\n\n  \nprint\n(\nmessage\n)\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nonMessage\n \n=\n \nfunction\n(\nmessage\n)\n \n{\n\n  \ntrace\n(\nserver just sent this message:\n);\n\n  \ntrace\n(\nStd\n.\nstring\n(\nmessage\n));\n\n\n};\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n\n\nTip\n\n\nTo send a message from the server directly to the clients you'll need to use\neither \nroom.send()\n or\n\nroom.broadcast()\n\n\n\n\nonJoin\n\n\nThis event is triggered when the client successfuly joins the room.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonJoin\n.\nadd\n(\nfunction\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nclient joined successfully\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnJoin\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nclient joined successfully\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n:\non\n(\njoin\n,\n \nfunction\n()\n\n  \nprint\n(\nclient joined successfully\n)\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nonJoin\n \n=\n \nfunction\n \n()\n \n{\n\n  \ntrace\n(\nclient joined successfully\n);\n\n\n};\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonLeave\n\n\nThis event is triggered when the client leave the room.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonLeave\n.\nadd\n(\nfunction\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nclient left the room\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnLeave\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nclient left the room\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n:\non\n(\nleave\n,\n \nfunction\n()\n\n  \nprint\n(\nclient left the room\n)\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nonLeave\n \n=\n \nfunction\n \n()\n \n{\n\n  \ntrace\n(\nclient left the room\n);\n\n\n};\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonError\n\n\nThis event is triggered when some error occurs in the room handler.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n            \nlua\n\n        \n\n    \n        \n\n            \nHaxe\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonError\n.\nadd\n(\nfunction\n(\nerr\n)\n \n{\n\n  \nconsole\n.\nlog\n(\noops, error ocurred:\n);\n\n  \nconsole\n.\nlog\n(\nerr\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnError\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\noops, error ocurred:\n);\n\n  \nDebug\n.\nLog\n(\ne\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n:\non\n(\nerror\n,\n \nfunction\n()\n\n  \nprint\n(\noops, error ocurred:\n)\n\n  \nprint\n(\ne\n)\n\n\nend\n)\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nonError\n \n=\n \nfunction\n(\nerr\n)\n \n{\n\n  \ntrace\n(\noops, error ocurred:\n);\n\n  \ntrace\n(\nerr\n);\n\n\n};", 
            "title": "Room"
        }, 
        {
            "location": "/client-room/#room-api-client-side", 
            "text": "", 
            "title": "Room API (Client-side)"
        }, 
        {
            "location": "/client-room/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/client-room/#listen-path-string-callback-function", 
            "text": "Listen to room state changes from the room handler.  Use this method to synchronize the room state from the server with the clients.", 
            "title": "listen (path: string, callback: Function)"
        }, 
        {
            "location": "/client-room/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/client-room/#listening-to-map-data-structures", 
            "text": "TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             import   {   DataChange   }   from   colyseus.js ;  // ...  room . listen ( players/:id ,   ( change :  DataChange )   =   { \n   if   ( change . operation   ===   add )   { \n     console . log ( new player added to the state ); \n     console . log ( player id: ,   change . path . id ); \n     console . log ( player data: ,   change . value ); \n\n   }   else   if   ( change . operation   ===   remove )   { \n     console . log ( player has been removed from the state ); \n     console . log ( player id: ,   change . path . id ); \n   }  });  \n\n         \n    \n         \n             using   Colyseus ;  // ...  room . Listen ( players/:id ,   OnPlayerChange );  void   OnPlayerChange   ( DataChange   change )  { \n   if   ( change . operation   ==   add )   { \n     Debug . Log   ( new player added to the state ); \n     Debug . Log   ( change . path [ id ]); \n     Debug . Log   ( change . value ); \n\n   }   else   if   ( change . operation   ==   remove )   { \n     Debug . Log   ( player has been removed from the state ); \n     Debug . Log   ( change . path [ id ]); \n   }  });  \n\n         \n    \n         \n             room : listen ( players/:id ,   function ( change ) \n   if   ( change . operation   ==   add )   then \n     print ( new player added to the state ) \n     print ( change . path [ id ]) \n     print ( change . value ) \n\n   elseif   ( change . operation   ==   remove )   then \n     print ( player has been removed from the state ) \n     print ( change . path [ id ]) \n   end  end )  \n\n         \n    \n         \n             room . listen ( players/:id ,   function   ( change )   { \n   if   ( change . operation   == =   add )   { \n     trace ( new player added to the state ); \n     trace ( player id:   +   change . path . id ); \n     trace ( player data:   +   Std . string ( change . value )); \n\n   }   else   if   ( change . operation   == =   remove )   { \n     trace ( player has been removed from the state ); \n     trace ( player id:   +   change . path . id ); \n   }  });", 
            "title": "Listening to map data structures"
        }, 
        {
            "location": "/client-room/#listening-to-attribute-changes-of-deep-data-structures", 
            "text": "TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             import   {   DataChange   }   from   colyseus.js ;  // ...  room . listen ( players/:id/:attribute ,   ( change :  DataChange )   =   { \n   console . log ( change . operation );   // =   add  |  remove  |  replace \n   console . log ( change . path . attribute ,   has been changed ); \n   console . log ( change . path . id ); \n   console . log ( change . value );  });  \n\n         \n    \n         \n             using   Colyseus ;  // ...  room . Listen ( players/:id/:attribute ,   OnPlayerAttributeChange );  void   OnPlayerAttributeChange   ( DataChange   change )  { \n   Debug . Log   ( change . operation );   // =   add  |  remove  |  replace \n   Debug . Log   ( change . path [ attribute ]   +   has been changed ); \n   Debug . Log   ( change . path [ id ]); \n   Debug . Log   ( change . value );  });  \n\n         \n    \n         \n             room : listen ( players/:id/:attribute ,   function () \n   print ( change . operation )   //   =   add   |   remove   |   replace \n   print ( change . path [ attribute ]   +   has been changed ) \n   print ( change . path [ id ]) \n   print ( change . value )  end )  \n\n         \n    \n         \n             room . listen ( players/:id/:attribute ,   function ( change )   { \n   trace ( change . operation );   // =   add  |  remove  |  replace \n   trace ( change . path . attribute   +    has been changed ); \n   trace ( change . path . id ); \n   trace ( Std . string ( change . value ));  });  \n\n         \n    \n         \n    \n                 \n                       Tip  See  State synchronization  for more examples on how to use the  listen  method.", 
            "title": "Listening to attribute changes of deep data structures"
        }, 
        {
            "location": "/client-room/#send-data", 
            "text": "Send message to the room handler.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             room . send ({   move :   left   });  \n\n         \n    \n         \n             room . Send ( new   {   move   =   left   });  \n\n         \n    \n         \n             room : send ({   move   =   left   })  \n\n         \n    \n         \n             room . send ({   move :   left   });  \n\n         \n    \n         \n    \n                 \n                      Use  Room#onMessage()  from the server-side to read the message.", 
            "title": "send (data)"
        }, 
        {
            "location": "/client-room/#leave", 
            "text": "Disconnect from the room.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             room . leave ();  \n\n         \n    \n         \n             room . Leave ();  \n\n         \n    \n         \n             room : leave ()  \n\n         \n    \n         \n             room . leave ();  \n\n         \n    \n         \n    \n                 \n                       Tip  Use  Room#onLeave()  to handle the disconnection from the server-side.", 
            "title": "leave ()"
        }, 
        {
            "location": "/client-room/#removealllisteners", 
            "text": "Remove all event and data listeners.", 
            "title": "removeAllListeners()"
        }, 
        {
            "location": "/client-room/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/client-room/#id-string", 
            "text": "The unique idenfitier of the room. You can share this id with other clients in\norder to allow them to connect directly to this room.  // get `roomId` from the query string  let   roomId   =   location . href . match ( /roomId=([a-zA-Z0-9\\-_]+)/ )[ 1 ];  // connect the client directly into a specific room id  let   room   =   client . join ( roomId );    Warning  If you're looking for the unique identifier of the client, use  client.id  instead.", 
            "title": "id: string"
        }, 
        {
            "location": "/client-room/#sessionid-string", 
            "text": "Unique session identifier.  This property matches the  client.sessionId  from the server-side.", 
            "title": "sessionId: string"
        }, 
        {
            "location": "/client-room/#name-string", 
            "text": "Name of the room handler. Ex:  \"battle\" .", 
            "title": "name: string"
        }, 
        {
            "location": "/client-room/#state-any", 
            "text": "The current room's state. This variable is always synched with the latest state  from the server-side. To listen for updates on the whole state, see onStateChange  event.", 
            "title": "state: any"
        }, 
        {
            "location": "/client-room/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/client-room/#onstatechange", 
            "text": "This event is triggered when the server updates its state.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             room . onStateChange . addOnce ( function ( state )   { \n   console . log ( this is the first room state! ,   state );  });  room . onStateChange . add ( function ( state )   { \n   console . log ( the room state has been updated: ,   state );  });  \n\n         \n    \n         \n             room . OnStateChange   +=   ( object   sender ,   RoomUpdateEventArgs   e )   =   { \n   if   ( e . isFirstState )   { \n     Debug . Log   ( this is the first room state! ); \n   } \n\n   Debug . Log   ( the room state has been updated );  }  \n\n         \n    \n         \n             room : on ( statechange ,   function ( state ) \n   print ( new state: ,   state )  end )  \n\n         \n    \n         \n             room . onStateChange   =   function ( state )   { \n   trace ( new state:   +   Std . string ( state ));  };", 
            "title": "onStateChange"
        }, 
        {
            "location": "/client-room/#onmessage", 
            "text": "This event is triggered when the server sends a message directly to the client.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             room . onMessage . add ( function ( message )   { \n   console . log ( server just sent this message: ); \n   console . log ( message );  });  \n\n         \n    \n         \n             room . OnMessage   +=   ( object   sender ,   MessageEventArgs   e )   =   { \n   Debug . Log   ( server just sent this message: ); \n   Debug . Log ( e . message );  }  \n\n         \n    \n         \n             room : on ( message ,   function ( message ) \n   print ( server just sent this message: ) \n   print ( message )  end )  \n\n         \n    \n         \n             room . onMessage   =   function ( message )   { \n   trace ( server just sent this message: ); \n   trace ( Std . string ( message ));  };  \n\n         \n    \n         \n    \n                 \n                       Tip  To send a message from the server directly to the clients you'll need to use\neither  room.send()  or room.broadcast()", 
            "title": "onMessage"
        }, 
        {
            "location": "/client-room/#onjoin", 
            "text": "This event is triggered when the client successfuly joins the room.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             room . onJoin . add ( function ()   { \n   console . log ( client joined successfully );  });  \n\n         \n    \n         \n             room . OnJoin   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( client joined successfully );  }  \n\n         \n    \n         \n             room : on ( join ,   function () \n   print ( client joined successfully )  end )  \n\n         \n    \n         \n             room . onJoin   =   function   ()   { \n   trace ( client joined successfully );  };", 
            "title": "onJoin"
        }, 
        {
            "location": "/client-room/#onleave", 
            "text": "This event is triggered when the client leave the room.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             room . onLeave . add ( function ()   { \n   console . log ( client left the room );  });  \n\n         \n    \n         \n             room . OnLeave   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( client left the room );  }  \n\n         \n    \n         \n             room : on ( leave ,   function () \n   print ( client left the room )  end )  \n\n         \n    \n         \n             room . onLeave   =   function   ()   { \n   trace ( client left the room );  };", 
            "title": "onLeave"
        }, 
        {
            "location": "/client-room/#onerror", 
            "text": "This event is triggered when some error occurs in the room handler.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n             lua \n         \n    \n         \n             Haxe \n         \n    \n         \n    \n         \n            \n         \n             room . onError . add ( function ( err )   { \n   console . log ( oops, error ocurred: ); \n   console . log ( err );  });  \n\n         \n    \n         \n             room . OnError   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( oops, error ocurred: ); \n   Debug . Log ( e );  }  \n\n         \n    \n         \n             room : on ( error ,   function () \n   print ( oops, error ocurred: ) \n   print ( e )  end )  \n\n         \n    \n         \n             room . onError   =   function ( err )   { \n   trace ( oops, error ocurred: ); \n   trace ( err );  };", 
            "title": "onError"
        }, 
        {
            "location": "/client-state-synchronization/", 
            "text": "Whenever the \nstate mutates\n in the server-side, you can listen to particular variable changes in the client-side.\n\n\nThe \nRoom\n instance in the client-side uses \ndelta-listener\n to allow you to trigger callbacks for particular mutations.\n\n\nExample\n\n\nLet's say you have a list of entities and its positions in your server-side:\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonInit\n \n()\n \n{\n\n        \nthis\n.\nsetState\n({\n\n            \nentities\n:\n \n{\n\n                \nf98h3f\n:\n \n{\n \nx\n:\n \n0\n,\n \ny\n:\n \n0\n,\n \nhp\n:\n \n10\n \n},\n\n                \n24jgd3\n:\n \n{\n \nx\n:\n \n100\n,\n \ny\n:\n \n0\n,\n \nhp\n:\n \n6\n \n}\n\n            \n}\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn the client-side, you want to listen for mutations in the attributes of these entities. Before being able to catch them, we need to mutate them. The mutation can occur during your simulation interval, or by actions taken by connected clients (during \nonMessage\n in the server-side).\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonInit\n \n()\n \n{\n\n        \n// this.setState(...) see above\n\n        \nthis\n.\nsetSimulationInterval\n(()\n \n=\n \nthis\n.\nupdate\n());\n\n    \n}\n\n\n    \nupdate\n \n()\n \n{\n\n        \nfor\n \n(\nlet\n \nentityId\n \nin\n \nthis\n.\nstate\n.\nentities\n)\n \n{\n\n            \n// simple and naive gravity\n\n            \nthis\n.\nstate\n.\nentities\n[\nentityId\n].\ny\n \n+=\n \n1\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow that we have the mutations in place, we can listen to them in the client-side. The callback will be called for each attribute, of each entity.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nlisten\n(\nentities/:id/:attribute\n,\n \n(\nchange\n)\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\nchange\n.\noperation\n);\n \n// =\n \nreplace\n (can be \nadd\n, \nremove\n or \nreplace\n)\n\n    \nconsole\n.\nlog\n(\nchange\n.\npath\n[\nid\n]);\n \n// =\n \nf98h3f\n\n    \nconsole\n.\nlog\n(\nchange\n.\npath\n[\nattribute\n]);\n \n// =\n \ny\n\n    \nconsole\n.\nlog\n(\nchange\n.\nvalue\n);\n \n// =\n 1\n\n\n})\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nListen\n(\nentities/:id/:attribute\n,\n \nOnAttributeChange\n);\n\n\n\nvoid\n \nOnAttributeChange\n \n(\nDataChange\n \nchange\n)\n\n\n{\n\n    \nDebug\n.\nLog\n \n(\nOnAttributeChange\n);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\noperation\n);\n \n// =\n \nreplace\n (can be \nadd\n, \nremove\n or \nreplace\n)\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n \n// =\n \nf98h3f\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nattribute\n]);\n \n// =\n \ny\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\nvalue\n);\n \n// =\n 1\n\n\n})", 
            "title": "State synchronization"
        }, 
        {
            "location": "/deployment/", 
            "text": "Deploying on Heroku\n\n\nDeploying on Zeit Now\n\n\nDeploying on Nginx (recommended)\n\n\n\n\nHeroku\n\n\nYou can deploy the \ncolyseus-examples\n project on Heroku by hitting this button:\n\n\n\n\nZeit Now\n\n\nYou can deploy the \ncolyseus-examples\n project on Zeit Now by hitting this button:\n\n\n\n\nNginx (recommended)\n\n\nIt's recommended to use \npm2\n and \nnginx\n in your production environment.\n\n\nPM2\n\n\nInstall \npm2\n in your environment.\n\n\nnpm install -g pm2\n\n\n\n\n\nThen start your game server using it:\n\n\npm2 start your-server.js -i 0\n\n\n\n\n\nNginx configuration\n\n\nserver {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \nupgrade\n;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}\n\n\n\n\n\nNginx configuration with SSL\n\n\nIt's recommended to acquire your certificate from \nLetsEncrypt\n.\n\n\nserver {\n    listen 80;\n    listen 443 ssl;\n    server_name yourdomain.com;\n\n    ssl_certificate /path/to/your/cert.crt;\n    ssl_certificate_key /path/to/your/cert.key;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \nupgrade\n;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Deployment"
        }, 
        {
            "location": "/deployment/#heroku", 
            "text": "You can deploy the  colyseus-examples  project on Heroku by hitting this button:", 
            "title": "Heroku"
        }, 
        {
            "location": "/deployment/#zeit-now", 
            "text": "You can deploy the  colyseus-examples  project on Zeit Now by hitting this button:", 
            "title": "Zeit Now"
        }, 
        {
            "location": "/deployment/#nginx-recommended", 
            "text": "It's recommended to use  pm2  and  nginx  in your production environment.", 
            "title": "Nginx (recommended)"
        }, 
        {
            "location": "/deployment/#pm2", 
            "text": "Install  pm2  in your environment.  npm install -g pm2  Then start your game server using it:  pm2 start your-server.js -i 0", 
            "title": "PM2"
        }, 
        {
            "location": "/deployment/#nginx-configuration", 
            "text": "server {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection  upgrade ;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Nginx configuration"
        }, 
        {
            "location": "/deployment/#nginx-configuration-with-ssl", 
            "text": "It's recommended to acquire your certificate from  LetsEncrypt .  server {\n    listen 80;\n    listen 443 ssl;\n    server_name yourdomain.com;\n\n    ssl_certificate /path/to/your/cert.crt;\n    ssl_certificate_key /path/to/your/cert.key;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection  upgrade ;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Nginx configuration with SSL"
        }, 
        {
            "location": "/migrating/", 
            "text": "Migrating between versions of Colyseus\n\n\nThis document presents all breaking changes on the framework, and what you need\nto do to keep your server working on the latest version.\n\n\nMigrating to 0.9.x (from 0.6.x or 0.8.x)\n\n\nServer-side\n\n\n\n\nClusterServer\n has been deprecated. Use \nServer\n instead.\n\n\nRoom#verifyClient(client, options)\n has been renamed to \nRoom#onAuth(options)\n\n\nIntegration with \nuws\n module has changed. See \nhow to integrate here\n.\n\n\n\n\nClient-side\n\n\ncolyseus.js\n\n\n\n\nroom.onData\n has been renamed to \nroom.onMessage\n.\n\n\nroom.onUpdate\n has been renamed to \nroom.onStateChange\n\n\nroom.data\n has been renamed to \nroom.state\n\n\n\n\ncolyseus-unity3d\n\n\n\n\nroom.OnData\n has been renamed to \nroom.OnMessage\n.\n\n\nroom.OnUpdate\n has been renamed to \nroom.OnStateChange\n\n\nroom.data\n has been renamed to \nroom.state\n\n\n\n\nMigrating to 0.5.x (from 0.4.x)\n\n\nUse \nServer#listen\n to bind http port.\n\n\nThe \nServer\n is now using the \nClusterServer\n under the hood, which will spawn\nworkers automatically. If you're using the \nServer\n instead of \nClusterServer\n\ndirectly, you should call its \nlisten\n method.\n\n\nOLD\n\n\nimport { createServer } from \nhttp\n;\nimport { Server } from \ncolyseus\n;\nconst httpServer = createServer(app);\nconst gameServer = new Server({ server: httpServer });\nhttpServer.listen(2657);\n\n\n\n\n\nNEW\n\n\nimport { createServer } from \nhttp\n;\nimport { Server } from \ncolyseus\n;\nconst httpServer = createServer(app);\nconst gameServer = new Server({ server: httpServer });\ngameServer.listen(2657); // calling \nlisten\n from gameServer instead of httpServer\n\n\n\n\n\nconstructor\n signature changed. use \nonInit\n instead.\n\n\nOLD\n\n\nconstructor (options) {\n  super(options);\n  // ... initialize the room\n}\n\n\n\n\n\nNEW\n\n\nconstructor () {\n  // room has been constructed. no options available yet!\n}\n\nonInit (options) {\n  // ... initialize the room\n}\n\n\n\n\n\nrequestJoin\n - can return type can be either \nboolean\n or \nnumber\n (\n0..1\n)\n\n\nOLD\n\n\nrequestJoin (options) {\n  // accept connections if this room is not full.\n  return this.clients.length \n 10;\n}\n\n\n\n\n\nNEW\n\n\nrequestJoin (options) {\n  // give priority to connect on rooms with fewer clients.\n  return 1 - (this.clients.length) / 10;\n}\n\n\n\n\n\nuse \npatchRate\n property instead of \nsetPatchRate()\n method.\n\n\nOLD\n\n\nconstructor (options) {\n  this.setPatchRate(1000 / 50);\n}\n\n\n\n\n\nNEW\n\n\nclass MyRoom extends Room {\n  patchRate = 1000 / 50;\n}\n\n\n\n\n\nclient.id\n / \nclient.sessionId\n\n\n\n\nclient.sessionId\n - is a unique identifier of a user connected in a room.\n\n\nclient.id\n - is a unique identifier of a user. if the user connects to the same room twice, you can identify he has two sessions by checking for \nclient.id\n. If you don't bother having the same user connected multiple times in a room, always use \nclient.sessionId\n to identify it.\n\n\n\n\nnew \nroom.maxClients\n property.\n\n\nOLD - if you're just checking for \nclient.length\n on \nrequestJoin\n, you probably can switch to \nmaxClients\n instead.\n\n\nrequestJoin (options) {\n  return this.clients.length \n 10;\n}\n\n\n\n\n\nNEW\n\n\nclass MyRoom extends Room {\n  maxClients = 10;\n}\n\n\n\n\n\nMigrating to 0.4.x (from 0.3.x)\n\n\nconstructor / patch-rate\n\n\nOLD constructor / patch-rate\n\n\nclass MyRoom extends Room {\n  constructor ( options ) {\n    super( options, PATH_RATE )\n  }\n}\n\n\n\n\n\nNEW constructor / patch-rate\n\n\nclass MyRoom extends Room {\n  constructor ( options ) {\n    super( options )\n    this.setPatchRate( PATCH_RATE )\n  }\n}", 
            "title": "Migrating"
        }, 
        {
            "location": "/migrating/#migrating-between-versions-of-colyseus", 
            "text": "This document presents all breaking changes on the framework, and what you need\nto do to keep your server working on the latest version.", 
            "title": "Migrating between versions of Colyseus"
        }, 
        {
            "location": "/migrating/#migrating-to-09x-from-06x-or-08x", 
            "text": "", 
            "title": "Migrating to 0.9.x (from 0.6.x or 0.8.x)"
        }, 
        {
            "location": "/migrating/#server-side", 
            "text": "ClusterServer  has been deprecated. Use  Server  instead.  Room#verifyClient(client, options)  has been renamed to  Room#onAuth(options)  Integration with  uws  module has changed. See  how to integrate here .", 
            "title": "Server-side"
        }, 
        {
            "location": "/migrating/#client-side", 
            "text": "", 
            "title": "Client-side"
        }, 
        {
            "location": "/migrating/#colyseusjs", 
            "text": "room.onData  has been renamed to  room.onMessage .  room.onUpdate  has been renamed to  room.onStateChange  room.data  has been renamed to  room.state", 
            "title": "colyseus.js"
        }, 
        {
            "location": "/migrating/#colyseus-unity3d", 
            "text": "room.OnData  has been renamed to  room.OnMessage .  room.OnUpdate  has been renamed to  room.OnStateChange  room.data  has been renamed to  room.state", 
            "title": "colyseus-unity3d"
        }, 
        {
            "location": "/migrating/#migrating-to-05x-from-04x", 
            "text": "", 
            "title": "Migrating to 0.5.x (from 0.4.x)"
        }, 
        {
            "location": "/migrating/#use-serverlisten-to-bind-http-port", 
            "text": "The  Server  is now using the  ClusterServer  under the hood, which will spawn\nworkers automatically. If you're using the  Server  instead of  ClusterServer \ndirectly, you should call its  listen  method.  OLD  import { createServer } from  http ;\nimport { Server } from  colyseus ;\nconst httpServer = createServer(app);\nconst gameServer = new Server({ server: httpServer });\nhttpServer.listen(2657);  NEW  import { createServer } from  http ;\nimport { Server } from  colyseus ;\nconst httpServer = createServer(app);\nconst gameServer = new Server({ server: httpServer });\ngameServer.listen(2657); // calling  listen  from gameServer instead of httpServer", 
            "title": "Use Server#listen to bind http port."
        }, 
        {
            "location": "/migrating/#constructor-signature-changed-use-oninit-instead", 
            "text": "OLD  constructor (options) {\n  super(options);\n  // ... initialize the room\n}  NEW  constructor () {\n  // room has been constructed. no options available yet!\n}\n\nonInit (options) {\n  // ... initialize the room\n}", 
            "title": "constructor signature changed. use onInit instead."
        }, 
        {
            "location": "/migrating/#requestjoin-can-return-type-can-be-either-boolean-or-number-01", 
            "text": "OLD  requestJoin (options) {\n  // accept connections if this room is not full.\n  return this.clients.length   10;\n}  NEW  requestJoin (options) {\n  // give priority to connect on rooms with fewer clients.\n  return 1 - (this.clients.length) / 10;\n}", 
            "title": "requestJoin - can return type can be either boolean or number (0..1)"
        }, 
        {
            "location": "/migrating/#use-patchrate-property-instead-of-setpatchrate-method", 
            "text": "OLD  constructor (options) {\n  this.setPatchRate(1000 / 50);\n}  NEW  class MyRoom extends Room {\n  patchRate = 1000 / 50;\n}", 
            "title": "use patchRate property instead of setPatchRate() method."
        }, 
        {
            "location": "/migrating/#clientid-clientsessionid", 
            "text": "client.sessionId  - is a unique identifier of a user connected in a room.  client.id  - is a unique identifier of a user. if the user connects to the same room twice, you can identify he has two sessions by checking for  client.id . If you don't bother having the same user connected multiple times in a room, always use  client.sessionId  to identify it.", 
            "title": "client.id / client.sessionId"
        }, 
        {
            "location": "/migrating/#new-roommaxclients-property", 
            "text": "OLD - if you're just checking for  client.length  on  requestJoin , you probably can switch to  maxClients  instead.  requestJoin (options) {\n  return this.clients.length   10;\n}  NEW  class MyRoom extends Room {\n  maxClients = 10;\n}", 
            "title": "new room.maxClients property."
        }, 
        {
            "location": "/migrating/#migrating-to-04x-from-03x", 
            "text": "", 
            "title": "Migrating to 0.4.x (from 0.3.x)"
        }, 
        {
            "location": "/migrating/#constructor-patch-rate", 
            "text": "OLD constructor / patch-rate  class MyRoom extends Room {\n  constructor ( options ) {\n    super( options, PATH_RATE )\n  }\n}  NEW constructor / patch-rate  class MyRoom extends Room {\n  constructor ( options ) {\n    super( options )\n    this.setPatchRate( PATCH_RATE )\n  }\n}", 
            "title": "constructor / patch-rate"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\nHow would I broadcast data from one client to others?\n\n\nYou usually don't do that. By using an authoritative game server, the clients generally send \nactions\n to the server, and the server \nmutates\n the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval.\n\n\nDo I need client-prediction in my game? Does Colyseus help me with this?\n\n\nColyseus does not provide any client-prediction solution out of the box. Games such as \nwilds.io\n and \ncrashracing.com\n do not use any form of client-prediction. \nlerp\ning user coordinates usually gives reasonable results.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#how-would-i-broadcast-data-from-one-client-to-others", 
            "text": "You usually don't do that. By using an authoritative game server, the clients generally send  actions  to the server, and the server  mutates  the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval.", 
            "title": "How would I broadcast data from one client to others?"
        }, 
        {
            "location": "/faq/#do-i-need-client-prediction-in-my-game-does-colyseus-help-me-with-this", 
            "text": "Colyseus does not provide any client-prediction solution out of the box. Games such as  wilds.io  and  crashracing.com  do not use any form of client-prediction.  lerp ing user coordinates usually gives reasonable results.", 
            "title": "Do I need client-prediction in my game? Does Colyseus help me with this?"
        }, 
        {
            "location": "/roadmap/", 
            "text": "Overview:\n\n\n\n\nSupport vertical scalability (\n#43\n)\n - \u2714\n\n\nStandardize how to authenticate users in a secure way. (\n#49\n, suggested by \n@darkyen\n)\n - \u2714\n\n\nPM2 support (\n#56\n)\n - \u2714\n\n\nSupport horizontal scalability. (\n#57\n)\n - \u2714\n\n\nSupport for splitting and filtering views (\n#59\n, suggested by \n@darkyen\n and the whole \ngitter channel\n!)\n\n\nSupport serialization methods other than Fossil's Delta algorithm. (\n#58\n, suggested by \n@derwish-pro\n)\n\n\nSupport transport layers other than WebSocket. (\n#48\n, suggested by \n@darkyen\n)\n\n\n\n\nIn order to achieve these goals, it would be great to split Colyseus's internal parts as composable modules. Specially match-making, which is the most complex feature to deal with by having multiple servers/processes running.", 
            "title": "Roadmap"
        }, 
        {
            "location": "/roadmap/#overview", 
            "text": "Support vertical scalability ( #43 )  - \u2714  Standardize how to authenticate users in a secure way. ( #49 , suggested by  @darkyen )  - \u2714  PM2 support ( #56 )  - \u2714  Support horizontal scalability. ( #57 )  - \u2714  Support for splitting and filtering views ( #59 , suggested by  @darkyen  and the whole  gitter channel !)  Support serialization methods other than Fossil's Delta algorithm. ( #58 , suggested by  @derwish-pro )  Support transport layers other than WebSocket. ( #48 , suggested by  @darkyen )   In order to achieve these goals, it would be great to split Colyseus's internal parts as composable modules. Specially match-making, which is the most complex feature to deal with by having multiple servers/processes running.", 
            "title": "Overview:"
        }
    ]
}